grammar org.xtext.example.mydsl.Adeptness with org.eclipse.xtext.common.Terminals

generate adeptness "http://www.xtext.org/example/mydsl/Adeptness"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Adeptness:
	(elements+=AbstractElement)*
;

AbstractElement:
	PackageDeclaration | Type | Imports
;

Imports:
	'import' importedNamespace=QualifiedNameWithWildcard
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

QualifiedName:
	ID ('.' ID)*
;

Type:
	DataType | Signal | MonitoringFile
;

MonitoringFile:
	'MONITORINGPLAN' name=ID ':'
		(monitoringPlan+=MonitoringPlan)+'ENDMONITORINGPLAN'
		/*(check_static_upper+=Check_Static_upper_only)*
		(check_static_lower+=Check_Static_lower_only)*
		(check_range+=Check_Range)*
		(check_gap+=Check_Gap)*/
;


MonitoringPlan:
	monitoringVariables = MonitoringVariable 
	
;

/*MonitoringVariable: 
 //'MonitoringVariable' '{'
	(monitoringVariable+=MonVar)*	
  //'}';	*/
MonitoringVariable: 
	'MONITOR' name=ID ':'
		'type'':' (MonitoringVariableDatatype = Sig_type)
		('max'':' max = DOUBLE
		'min'':' min = DOUBLE)?
		//(monvar+=MonVar)+
		'ENDMONITOR'
;	


/*MonVar:
	//'sig:' name = ID'{'
		'type:' MonitoringVariableDatatype = Sig_type
		//'signalPattern:' sigPattern = SigPattern
		//('unit:' unit = STRING)?
		('max:' max = DOUBLE
		'min:' min = DOUBLE)?
		//('timePeriod:' timePeriod_down = DOUBLE 'to' timePeriod_up = DOUBLE)?
	//'}'
;*/

Sig_type:
	((sig_type = 'boolean')|(sig_type = 'int' )|(sig_type = 'double' ))
;

//Each signal could have more than one oracles
Signal:
	//imp = ImportMonitoringPlan
	'CPS' name=ID ('[' cardinalityNumCPS = INT ']')? ':' ('implements'superType=[MonitoringFile|QualifiedName])?
		(oracle+=Oracle)+'ENDCPS'
		/*(check_static_upper+=Check_Static_upper_only)*
		(check_static_lower+=Check_Static_lower_only)*
		(check_range+=Check_Range)*
		(check_gap+=Check_Gap)*/
;

ImportMonitoringPlan:
	'import' importURI = STRING
;

Oracle: 
	'ORACLE' name=ID ':'
		(when=When|while=While)?
		(check=Checks)'ENDORACLE'
;

While:
	'while:' em = ExpressionsModel
			//precondReference = PrecondReference
;

When:
	'when:' em = ExpressionsModel
			(aw = AfterWhen)?
			//precondReference = PrecondReference
;

AfterWhen:
	(wait = Wait | during = During)
;

Wait:
	'after('  time = DOUBLE ',' unit=TimeType ')'
;

During:
	'during(' time = DOUBLE  ','  unit=TimeType ')'
;

Checks:
	'checks:' (name=ID |em = ExpressionsModel) //'is'
	(reference=Reference)
	(failReason+=FailReason)+
	(description=Description) //','
	
;

Description:
	'Description: ' value=STRING
;

FailReason:
	'fails if :'
	(reason=Reason)
	
;

Reason:
	((highPeak=HighPeak)|(highTime=HighTime)|(constDeg=ConstDeg)|(xPeaks=XPeaks)) ';'
;

XPeaks:
	'confidence is below' (cant=DOUBLE) 'more than' (nPeaks=DOUBLE) 'times within' (time=DOUBLE) (unit=TimeType) //nola jarri integer-ak?
;

ConstDeg:
	'confidence is in constant degradation'  (cant=DOUBLE) //(((upper=Upper)|(lower=Lower)))
;

HighTime:
	'confidence is below' (cant=DOUBLE) 'within' (time=DOUBLE) (unit=TimeType)
;

HighPeak:
	'confidence is below' (cant=DOUBLE)
;
Reference:
	((upper=Upper)|(lower=Lower)|(range=Range)|(gap=Gap)|(same=Same)|(notsame=NotSame))';'
;

PrecondReference:
	((upper=Upper)|(lower=Lower)|(range=Range)|(gap=Gap)|(same=Same)|(notsame=NotSame))';'
;

Same:
	'should be' (bound_upp=Bound_up) 
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;

NotSame:
	'should not be' (bound_upp=Bound_up)
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;

//Oracle for upper limit --> Below reference signal
Upper:
	'is below' (bound_upp=Bound_up)
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;
//Oracle for lower limit --> Above reference signal
Lower:
	'is above' (bound_lower=Bound_Down)
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;
//Oracle for Above and Below limit --> In range reference signal
Range:
	'is in range between' (bound_lower=Bound_Down) 'and' (bound_upp=Bound_up)
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;
//Oracle for !Above and !Below limit --> Gap reference signal
Gap:
	'not in range between' (bound_lower=Bound_Down) 'and' (bound_upp=Bound_up)
	((exactly=Exactly)| (atmost=At_most)| (atleast=At_least))?
;

//If the limits must be included ==
InclusiveBound:
	'inclusiveBound' name=ID '=' value= BOOLEAN
;

//exactly at a especified time
Exactly:
	'exactly'
	value=DOUBLE 
	('times' | 'times in' (time=DOUBLE) (unit=TimeType) | (unit=TimeType))
	 
;
At_most:
	'at most'
	value=DOUBLE 
	('times' | 'times in' (time=DOUBLE) (unit=TimeType) | (unit=TimeType))
;
At_least:
	'at least'
	value=DOUBLE 
	('times' | 'times in' (time=DOUBLE) (unit=TimeType) | (unit=TimeType))
;

//Upper limit

Bound_up:
	(value=DOUBLE|/*variable=AbstractElement2|*/em = ExpressionsModel)
;

//Lower limit
Bound_Down:
	 (value=DOUBLE|/*variable=AbstractElement2|*/em = ExpressionsModel)
;
//Boolean declaration
BOOLEAN:
	bool=b	
;
b returns ecore::EBoolean: 'true' | 'false';
//Double declaration
DOUBLE:
	dVal = d
;
d returns ecore::EDouble : ('-')? INT('.'INT)?;


TimeType:
	((time='milliseconds')|(time='seconds')|(time='minutes')|(time='hours'))
;

//DataType declaration
DataType:
	'datatype' name=ID
;
//Package declaration
PackageDeclaration:
	'package' name=QualifiedName '{'
		(elements+=AbstractElement)*
	'}'	
;

/*
 * MATH ELEMENTS
 */
 ExpressionsModel:

 	(elements+=AbstractElement2)*

;

 AbstractElement2:
 	(frontParentheses+=FrontParentheses)*
	((name=ID) | (value=DOUBLE))
	(op+=Operators)*

	
;
FrontParentheses:
	"("
;
BackParentheses:
	")"
;
Operators:
	(operator=Op|comparation=CompOp|logicOperator=LogicOp| backParentheses=BackParentheses)
;

CompOp:
	op=("=="|"!="|">="|"<="|"<"|">")
;

LogicOp:
	op=("&&"|"||")
;

Op:
	op=("+"|"-"|"*"|"/")
;
/*
ExpressionsModel:
	 (elements+=AbstractElement2)*;
AbstractElement2:
	Variable | EvalExpression;
Variable:
	name = ID   ('=' expression=Expression)? // TODO:  ('=' expression=Expression)? jarrita, bestela ez doa
;
	//"var" name=ID '=' expression=Expression;

MonitoringVariableExpresion:
	name=ID
;	
	
EvalExpression:
	expression=Expression;
Expression: Or;

Or returns Expression:

And (
{Or. left =current} '||' right=And
)*;

And returns Expression:
	Equality (
		{And.left=current} '&&' right=Equality
	)*;

Equality returns Expression:
	Comparison (
	{Equality . left =current} op=('==' | '!=')
	right=Comparison
)*;

Comparison returns Expression:
	PlusOrMinus (
	{Comparison.left=current} op=('>=' | '<=' | '>' | '<')
	right=PlusOrMinus
)*;

PlusOrMinus returns Expression:
	MulOrDiv (
	({ Plus. left =current} '+' | {Minus.left=current} '-')
	right=MulOrDiv
	)*;

MulOrDiv returns Expression:
	Primary (
	({MulOrDiv.left=current} op=('*' | '/' | '^'))
	right=Primary
	)*;
Primary returns Expression:
'(' Expression ')' |
{Not} '!' expression=Primary |
Atomic ;

Atomic returns Expression: //TODO: Support for doubles and negative values (negatives can be handled with 0-1)
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true' | 'false') |
	variable=Variable ;
*/
/*------------------------ANOHER EXPRESIONS MATHS------------------------ */

/*Math:
  expression=Expression;
    
Expression:
  Addition;
    
Addition returns Expression:
  Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;
    
Multiplication returns Expression:
  PrimaryExpression (({Multi.left=current} '*' | {Div.left=current} '/') right=PrimaryExpression)*;
    
PrimaryExpression returns Expression:
  '(' Expression ')' |
   {NumberLiteral} value=NUMBER;

terminal NUMBER returns ecore::EBigDecimal:
  ('0'..'9')* ('.' ('0'..'9')+)?;
    

@Override
terminal INT returns ecore::EInt:
  'this one has been deactivated';
  
*/


/*------------------------------------------------------- */
/*
Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)*;
  
Multiplication returns Expression:
  Primary ({Multiplication.left=current} '*' right=Primary)*;
  
Primary returns Expression:
  NumberLiteral |
  '(' Addition ')';
  
NumberLiteral:
  value=INT;
 */
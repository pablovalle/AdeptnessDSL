/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.validation;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ComposedChecks;
import org.xtext.example.mydsl.adeptness.AbstractElement2;
import org.xtext.example.mydsl.adeptness.AdeptnessPackage;
import org.xtext.example.mydsl.adeptness.At_least;
import org.xtext.example.mydsl.adeptness.At_most;
import org.xtext.example.mydsl.adeptness.BernoulliDistribution;
import org.xtext.example.mydsl.adeptness.Checks;
import org.xtext.example.mydsl.adeptness.ConstDeg;
import org.xtext.example.mydsl.adeptness.DOUBLE;
import org.xtext.example.mydsl.adeptness.Exactly;
import org.xtext.example.mydsl.adeptness.ExpressionsModel;
import org.xtext.example.mydsl.adeptness.FailReason;
import org.xtext.example.mydsl.adeptness.Gap;
import org.xtext.example.mydsl.adeptness.HighPeak;
import org.xtext.example.mydsl.adeptness.HighTime;
import org.xtext.example.mydsl.adeptness.Lower;
import org.xtext.example.mydsl.adeptness.MonitoringFile;
import org.xtext.example.mydsl.adeptness.MonitoringVariable;
import org.xtext.example.mydsl.adeptness.NormalDistribution;
import org.xtext.example.mydsl.adeptness.NotSame;
import org.xtext.example.mydsl.adeptness.Oracle;
import org.xtext.example.mydsl.adeptness.Range;
import org.xtext.example.mydsl.adeptness.Reference;
import org.xtext.example.mydsl.adeptness.Same;
import org.xtext.example.mydsl.adeptness.Signal;
import org.xtext.example.mydsl.adeptness.UncertaintyProb;
import org.xtext.example.mydsl.adeptness.Upper;
import org.xtext.example.mydsl.adeptness.When;
import org.xtext.example.mydsl.adeptness.While;
import org.xtext.example.mydsl.adeptness.XPeaks;


/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators= {UncertaintyValidator.class})
public class AdeptnessValidator extends AbstractAdeptnessValidator {

	double cantHigh;
	double cantTime;
	double cantDeg;
	double cantXPeak;
	// TODO if variable of type Map<String, MonitoringVariables> where key
	// is monitoringVariableName is used, checks related to variable in list would
	// be faster
	// Map<String, MonitoringVariables> monitoringVariables;
	List<MonitoringVariables> monitoringVariableList;
	List<String> oracleNames;
	List<String> monitoringVariableNames;

	OperationalDataConnector opCon = new OperationalDataConnector();

	// GET MONITORING VARIABLES
	@Check
	public void getImportedMonitoringVariables(Signal CPS) {
		// TODO Executed on every change. Ideal scenario: execute this function the
		// first time a change within this CPS is done.
		monitoringVariableList = new ArrayList<>();
//		monitoringVariables =  new HashMap<String, MonitoringVariables>();

		String type, name;
		double min, max;
		for (int i = 0; i < CPS.getSuperType().getMonitoringPlan().size(); i++) {
			MonitoringVariable monitor = CPS.getSuperType().getMonitoringPlan().get(i).getMonitoringVariables();
			name = monitor.getName().toString();
			type = monitor.getMonitoringVariableDatatype().getSig_type().toString();
			if (type.equals("boolean")) {
				max = 1;
				min = 0;
			} else {
				max = monitor.getMax().getDVal();
				min = monitor.getMin().getDVal();
			}
			MonitoringVariables monitoringVar = new MonitoringVariables(name, type, max, min);
			// if no data was retrieved, opData will be null
			monitoringVar.setOpData(opCon.getVariableOpData(name));

			monitoringVariableList.add(monitoringVar);
//			monitoringVariables.put(name, monitoringVar);
		}
	}

	@Check
	public void getMonitoringVariablesNames(MonitoringFile file) {
		monitoringVariableNames = new ArrayList<>();
		for (int i = 0; i < file.getMonitoringPlan().size(); i++) {
			monitoringVariableNames.add(file.getMonitoringPlan().get(i).getMonitoringVariables().getName().toString());
		}
	}

	@Check
	public void checkDuplicatedMonitoringVariableNames(MonitoringVariable variable) {
		String name = variable.getName().toString();
		int cont = 0;
		for (int i = 0; i < monitoringVariableNames.size(); i++) {
			if (monitoringVariableNames.get(i).toString().equals(name)) {
				cont++;
				if (cont > 1) {
					error("Monitoring Variables' name must be unique",
							AdeptnessPackage.Literals.MONITORING_VARIABLE__NAME);
					break;
				}
			}
		}

	}

	@Check
	public void getOraclesNames(Signal CPS) {
		oracleNames = new ArrayList<>();
		for (int i = 0; i < CPS.getOracle().size(); i++) {
			oracleNames.add(CPS.getOracle().get(i).getName().toString());
		}
	}

	@Check
	public void checkDuplicatedOracleNames(Oracle oracle) {
		String name = oracle.getName().toString();
		int cont = 0;
		for (int i = 0; i < oracleNames.size(); i++) {
			if (oracleNames.get(i).toString().equals(name)) {
				cont++;
			}
		}
		if (cont > 1) {
			error("Oracle's name must be unique", AdeptnessPackage.Literals.ORACLE__NAME);
		}
	}

	@Check
	public void checkTemporaryConditionsInCheckOnlyWithWhenPrecond(Oracle oracle) {
		if (oracle.getCheck().getReference().getUpper() != null
				&& (oracle.getCheck().getReference().getUpper().getAtleast() != null
						|| oracle.getCheck().getReference().getUpper().getAtmost() != null
						|| oracle.getCheck().getReference().getUpper().getExactly() != null)
				|| (oracle.getCheck().getReference().getLower() != null
						&& (oracle.getCheck().getReference().getLower().getAtleast() != null
								|| oracle.getCheck().getReference().getLower().getAtmost() != null
								|| oracle.getCheck().getReference().getLower().getExactly() != null))
				|| (oracle.getCheck().getReference().getRange() != null
						&& (oracle.getCheck().getReference().getRange().getAtleast() != null
								|| oracle.getCheck().getReference().getRange().getAtmost() != null
								|| oracle.getCheck().getReference().getRange().getExactly() != null))
				|| (oracle.getCheck().getReference().getGap() != null
						&& (oracle.getCheck().getReference().getGap().getAtleast() != null
								|| oracle.getCheck().getReference().getGap().getAtmost() != null
								|| oracle.getCheck().getReference().getGap().getExactly() != null))
				|| (oracle.getCheck().getReference().getSame() != null
						&& (oracle.getCheck().getReference().getSame().getAtleast() != null
								|| oracle.getCheck().getReference().getSame().getAtmost() != null
								|| oracle.getCheck().getReference().getSame().getExactly() != null))
				|| (oracle.getCheck().getReference().getNotsame() != null
						&& (oracle.getCheck().getReference().getNotsame().getAtleast() != null
								|| oracle.getCheck().getReference().getNotsame().getAtmost() != null
								|| oracle.getCheck().getReference().getNotsame().getExactly() != null))) {
			if (oracle.getWhen() == null) {
				error("Temporary conditions should only be used in conjuction with \"when\" preconditions.", AdeptnessPackage.Literals.ORACLE__CHECK);
			}
			for (FailReason fr : oracle.getCheck().getFailReason()) {
				if (fr.getReason().getHighTime() != null || fr.getReason().getXPeaks() != null ) {
					error("Temporary conditions are either set within the assertion or the failure statement, but not in both.", AdeptnessPackage.Literals.ORACLE__CHECK);
				}
			}
		}
	}
	
	

	@Check
	public void checkHighTimeAndHighPeak(Checks check) {
		boolean HT = false;
		boolean HP = false;
		int numHT = 0, numHP = 0;
		for (int i = 0; i < check.getFailReason().size(); i++) {
			if (check.getFailReason().get(i).getReason().getHighTime() != null) {
				HT = true;
				numHT = i;
			} else if (check.getFailReason().get(i).getReason().getHighPeak() != null) {
				HP = true;
				numHP = i;
			}
		}
		if (HT && HP) {
			HighTime Ht = check.getFailReason().get(numHT).getReason().getHighTime();
			HighPeak Hp = check.getFailReason().get(numHP).getReason().getHighPeak();
			if (Ht.getCant().getDVal() <= Hp.getCant().getDVal()) {
				error("The high peak reference confidence value must be lower than high time out of bounds confidence value",
						AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
			}
		}
	}

	@Check
	public void checkConfidenceHighPeak(HighPeak HPeak) {
		if (HPeak != null) {
			cantHigh = HPeak.getCant().getDVal();
			if (cantHigh < -1 || cantHigh > 0) {
				error("The confidence value must be between -1 and 0", AdeptnessPackage.Literals.HIGH_PEAK__CANT);
			}
		} else {
			System.out.println("TODO can HPeak be null?");

		}
	}

	@Check
	public void checkCheckSignal(Checks check) {
		// Left part in check must contain at least a variable name
		List<AbstractElement2> elems = check.getEm().getElements();
		boolean anyVar = false;
		for (AbstractElement2 elem : elems) {
			if (elem.getName() != null || elem.getUncer()!= null) {
				anyVar = true;
				break;
			}
		}
		if (!anyVar) {
			error("Checks' left part must represent a signal, can not be a value.",
					AdeptnessPackage.Literals.CHECKS__EM);
		}
	}

	@Check
	public void checkFailsIfCount(Checks check) {
		int highPeakCount = 0, highTimeCount = 0, xPeaksCount = 0, constDegCount = 0;
		for (FailReason fr : check.getFailReason()) {
			if (fr.getReason().getHighPeak() != null) {
				highPeakCount++;
				if (highPeakCount > 1) {
					error("Duplicated high peak failure detection.", AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
				}
			} else if (fr.getReason().getHighTime() != null) {
				highTimeCount++;
				if (highTimeCount > 1) {
					error("Duplicated high time out of bounds failure detection.",
							AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
				}
			} else if (fr.getReason().getXPeaks() != null) {
				xPeaksCount++;
				if (xPeaksCount > 1) {
					error("Duplicated more than n peaks in less than t seconds failure detection.",
							AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
				}
			} else if (fr.getReason().getConstDeg() != null) {
				constDegCount++;
				if (constDegCount > 1) {
					error("Duplicated constant degradation failure detection.",
							AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
				}
			}
		}
	}

	@Check
	public void checkFailsIfWithOperationalData(Checks check) {
		// TODO assess expressionmodels
		if (check.getName() == null)
			return;

		String signal = check.getName();
		for (MonitoringVariables mVar : monitoringVariableList) {
			if (mVar.getName().equals(signal)) {
				Double boundUp = null;
				Double boundDown = null;

				Reference reference = check.getReference();
				// get lower and upper bounds
				if (reference.getUpper() != null) {
					if (reference.getUpper().getBound_upp().getValue() != null) {
						boundUp = reference.getUpper().getBound_upp().getValue().getDVal();
					}
				} else if (reference.getLower() != null) {
					if (reference.getLower().getBound_lower().getValue() != null) {
						boundDown = reference.getLower().getBound_lower().getValue().getDVal();
					}
				} else if (reference.getRange() != null) {
					if (reference.getRange().getBound_lower().getValue() != null) {
						boundDown = reference.getRange().getBound_lower().getValue().getDVal();
					}
					if (reference.getRange().getBound_upp().getValue() != null) {
						boundUp = reference.getRange().getBound_upp().getValue().getDVal();
					}
				} else if (reference.getGap() != null) {
					if (reference.getGap().getBound_lower().getValue() != null) {
						boundDown = reference.getGap().getBound_lower().getValue().getDVal();
					}
					if (reference.getGap().getBound_upp().getValue() != null) {
						boundUp = reference.getGap().getBound_upp().getValue().getDVal();
					}
				} else if (reference.getSame() != null) {
					if (reference.getSame().getBound_upp().getValue() != null) {
						boundUp = reference.getSame().getBound_upp().getValue().getDVal();
					}
				} else if (reference.getNotsame() != null) {
					if (reference.getNotsame().getBound_upp().getValue() != null) {
						boundUp = reference.getNotsame().getBound_upp().getValue().getDVal();
					}
				}

				// TODO get bounds from expressionmodel
				if (boundUp == null && boundDown == null)
					return;

				boolean opDataOutOfBounds = false;
				int nPeaks;
				int nSamples;
				Double confidence = 0.0;
				Double maxBoundDown;
				Double minBoundUp;
				for (FailReason fr : check.getFailReason()) {
					// get confidence, nPeaks, and nSamples
					nSamples = 1;
					nPeaks = 1;
					if (fr.getReason().getHighPeak() != null) {
						confidence = fr.getReason().getHighPeak().getCant().getDVal();
					} else if (fr.getReason().getHighTime() != null) {
						confidence = fr.getReason().getHighTime().getCant().getDVal();
						nSamples = Utils.getNSamples((int) fr.getReason().getHighTime().getTime().getDVal(),
								fr.getReason().getHighTime().getUnit().getTime());
						nPeaks = nSamples;
					} else if (fr.getReason().getXPeaks() != null) {
						confidence = fr.getReason().getXPeaks().getCant().getDVal();
						nPeaks = (int) fr.getReason().getXPeaks().getNPeaks().getDVal();
						nSamples = Utils.getNSamples((int) fr.getReason().getXPeaks().getTime().getDVal(),
								fr.getReason().getXPeaks().getUnit().getTime());
					} else if (fr.getReason().getConstDeg() != null) {
						confidence = fr.getReason().getConstDeg().getCant().getDVal();
						// TODO
						return;
					}

					if (nSamples == 0 || nPeaks == 0) {
						error("Duration or number of peaks cannot be zero.",
								AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
					}

					// check oracle values against operational data
					// Upper
					if (reference.getUpper() != null && boundUp != null) {
						opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "upper",
								Utils.calcUpBound(confidence, mVar.getMax(), boundUp), nSamples, nPeaks);
					}
					// Lower
					else if (reference.getLower() != null && boundDown != null) {
						opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "lower",
								Utils.calcDownBound(confidence, mVar.getMin(), boundDown), nSamples, nPeaks);
					}
					// Range
					else if (reference.getRange() != null) {
						maxBoundDown = boundDown != null ? Utils.calcDownBound(confidence, mVar.getMin(), boundDown)
								: null;
						minBoundUp = boundUp != null ? Utils.calcUpBound(confidence, mVar.getMax(), boundUp) : null;

						if (boundDown != null && boundUp == null) {
							opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "lower",
									maxBoundDown, nSamples, nPeaks);
						} else if (boundDown == null && boundUp != null) {
							opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "upper",
									minBoundUp, nSamples, nPeaks);
						} else if (boundDown != null && boundUp != null) {
							opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "notInBetween",
									maxBoundDown, minBoundUp, nSamples, nPeaks);
						}
					}
					// Gap
					else if (reference.getGap() != null && boundDown != null && boundUp != null) {
						opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "inBetween",
								Utils.calcGapDownBound(confidence, mVar.getMin(), boundDown),
								Utils.calcGapUpBound(confidence, mVar.getMax(), boundUp), nSamples, nPeaks);
					}
					// Same
					else if (reference.getSame() != null && boundUp != null) {
						opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "notInBetween",
								Utils.calcDownBound(confidence, mVar.getMin(), boundUp),
								Utils.calcUpBound(confidence, mVar.getMax(), boundUp), nSamples, nPeaks);
					}
					// Not same
					else if (reference.getNotsame() != null && boundUp != null) {
						if (confidence != 0) {
							error("Confidence value must be zero within 'should not be' clauses or use a 'not in range' clause instead.",
									AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
							continue;
						}
						opDataOutOfBounds = this.checkOperationalDataOutOfBounds(mVar.getOpData(), "equal", boundUp,
								nSamples, nPeaks);
					}

					if (opDataOutOfBounds) {
						warning("There is operational data out of bounds.",
								AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
					}
				}
				break;
			}
		}

	}

	@Check
	public void checkConfidenceHighTime(HighTime HTime) {
		if (HTime != null) {
			cantTime = HTime.getCant().getDVal();
			if (cantTime < -1 || cantTime > 0) {
				error("The confidence value must be between -1 and 0", AdeptnessPackage.Literals.HIGH_TIME__CANT);
			}
		}

	}

	@Check
	public void checkConfidenceConstDeg(ConstDeg constDeg) {
		if (constDeg != null) {
			cantDeg = constDeg.getCant().getDVal();
			if (cantDeg < -1 || cantDeg > 0) {
				error("The confidence value must be between -1 and 0", AdeptnessPackage.Literals.CONST_DEG__CANT);
			}
		}

	}

	@Check
	public void checkConfidenceXPeaks(XPeaks xpeak) {
		if (xpeak != null) {
			cantXPeak = xpeak.getCant().getDVal();
			if (cantXPeak < -1 || cantXPeak > 0) {
				error("The confidence value must be between -1 and 0", AdeptnessPackage.Literals.XPEAKS__CANT);
			}
		}

	}

	@Check
	public void checkBooleanMinMaxValidation(MonitoringVariable monitoringVariable) {
		if (monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("boolean")
				&& (monitoringVariable.getMax() != null || monitoringVariable.getMin() != null)) {
			error("A boolean type signal can't have max and min values",
					AdeptnessPackage.Literals.MONITORING_VARIABLE__MONITORING_VARIABLE_DATATYPE);

		} else if ((monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("int")
				|| monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("double"))
				&& (monitoringVariable.getMax() == null || monitoringVariable.getMin() == null)) {
			error("An int or double type signal must have max and min values",
					AdeptnessPackage.Literals.MONITORING_VARIABLE__MONITORING_VARIABLE_DATATYPE);
		}

	}

	@Check
	public void checkMinMaxValues(MonitoringVariable monitoringVariable) {
		if (monitoringVariable.getMax().getDVal() < monitoringVariable.getMin().getDVal()) {
			error("Max value must be higher than min value", AdeptnessPackage.Literals.MONITORING_VARIABLE__MAX);
		}
	}

	@Check
	public void checkMonitoringVariables(Checks check) {
		if (check.getEm() != null) {
			System.out.println(
					"TODO Check if expressionsModel within Checks statement is correct according to min, max variable values in monitoring plan");
			return;
		}

		String checkName = check.getName().toString();

		double max, min;
		boolean is = false;
		for (int i = 0; i < monitoringVariableList.size(); i++) {
			if (checkName.equals(monitoringVariableList.get(i).getName())) {
				is = true;
				max = monitoringVariableList.get(i).getMax();
				min = monitoringVariableList.get(i).getMin();
				if (check.getReference().getUpper() != null) {
					// TODO getBound_upp to variable.
					Upper up = check.getReference().getUpper();

					if (up.getBound_upp().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Upper bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}

					// TODO value to variable.
					if (up.getBound_upp().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ up.getBound_upp().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (up.getBound_upp().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ up.getBound_upp().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
				} else if (check.getReference().getLower() != null) {
					// TODO getBound_lower to variable
					Lower low = check.getReference().getLower();

					if (low.getBound_lower().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Lower bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}

					// TODO value to variable.
					if (low.getBound_lower().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ low.getBound_lower().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (low.getBound_lower().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ low.getBound_lower().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
				} else if (check.getReference().getRange() != null) {
					Range range = check.getReference().getRange();

					if (range.getBound_lower().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Lower bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}
					if (range.getBound_upp().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Upper bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}

					if (range.getBound_upp().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ range.getBound_upp().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (range.getBound_upp().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ range.getBound_upp().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (range.getBound_lower().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ range.getBound_lower().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (range.getBound_lower().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ range.getBound_lower().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
				} else if (check.getReference().getGap() != null) {
					Gap gap = check.getReference().getGap();

					if (gap.getBound_lower().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Lower bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}
					if (gap.getBound_upp().getEm() != null) {
						System.out.println(
								"TODO Check if expressionsModel within Upper bound statement is correct according to min, max variable values in monitoring plan");
						continue;
					}

					if (gap.getBound_upp().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ gap.getBound_upp().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (gap.getBound_upp().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ gap.getBound_upp().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (gap.getBound_lower().getValue().getDVal() > max) {
						String errorString = "Check " + check.getName() + " with value: "
								+ gap.getBound_lower().getValue().getDVal() + " does not comply max value: " + max
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
					if (gap.getBound_lower().getValue().getDVal() < min) {
						String errorString = "Check " + check.getName() + " with value: "
								+ gap.getBound_lower().getValue().getDVal() + " does not comply min value: " + min
								+ " specified in the validation plan";
						error(errorString, AdeptnessPackage.Literals.CHECKS__REFERENCE);
					}
				}
				break;
			}
		}
		if (!is) {
			error("This variable is not in the monitoring plan", AdeptnessPackage.Literals.CHECKS__NAME);
		}
	}

	@Check
	public void checkMonitoringVariablesInPreconditions(AbstractElement2 precond) {
		String checkName = precond.getName().toString();
//		double max, min;
		boolean is = false;
		for (int i = 0; i < monitoringVariableList.size(); i++) {
			System.out.println(monitoringVariableList.get(i).getName());
			if (checkName.equals(monitoringVariableList.get(i).getName())) {
				System.out.println(checkName + "      " + monitoringVariableList.get(i).getName());
				is = true;

				break;
			}
		}
		if (!is) {
			error("This variable is not in the monitoring plan", AdeptnessPackage.Literals.ABSTRACT_ELEMENT2__NAME);
		}
	}

	
	@Check
	public void checkMonitoringVariablesNormalDistribution(NormalDistribution var) {
		String checkName = var.getName().toString();
//		double max, min;
		boolean is = false;
		for (int i = 0; i < monitoringVariableList.size(); i++) {
			System.out.println(monitoringVariableList.get(i).getName());
			if (checkName.equals(monitoringVariableList.get(i).getName())) {
				System.out.println(checkName + "      " + monitoringVariableList.get(i).getName());
				is = true;

				break;
			}
		}
		if (!is) {
			error("This variable is not in the monitoring plan", AdeptnessPackage.Literals.NORMAL_DISTRIBUTION__NAME);
		}
	}
	
	@Check
	public void checkMonitoringVariablesBernoulliDistribution(BernoulliDistribution var) {
		String checkName = var.getName().toString();
//		double max, min;
		boolean is = false;
		for (int i = 0; i < monitoringVariableList.size(); i++) {
			System.out.println(monitoringVariableList.get(i).getName());
			if (checkName.equals(monitoringVariableList.get(i).getName())) {
				System.out.println(checkName + "      " + monitoringVariableList.get(i).getName());
				is = true;

				break;
			}
		}
		if (!is) {
			error("This variable is not in the monitoring plan", AdeptnessPackage.Literals.BERNOULLI_DISTRIBUTION__NAME);
		}
	}
	
	@Check
	public void checkExpressions(ExpressionsModel data) {
		int conOpenPar = 0, conClosePar = 0;
		for (int i = 0; i < data.getElements().size(); i++) {
			AbstractElement2 elements = data.getElements().get(i);
			conOpenPar = conOpenPar + elements.getFrontParentheses().size();
			// current element (which is not the first one) contains name or value,
			// and preceding element also contains name or value.
			if (i > 0 && (elements.getName() != null || elements.getValue() != null)
					&& (data.getElements().get(i - 1).getName() != null
							|| data.getElements().get(i - 1).getValue() != null)) {
				// preceding element does not contain operation.
				// Example: "var 1" or "var ( var"
				if (data.getElements().get(i - 1).getOp().size() == 0) {
					error("Two values or signals can't be concatenated without an operator:",
							AdeptnessPackage.Literals.EXPRESSIONS_MODEL__ELEMENTS);
				}
			}
			for (int j = 0; j < elements.getOp().size(); j++) {
				if (elements.getOp().get(j).getBackParentheses() != null) {
					conClosePar++;
				}
				// TODO current operator from operators collection has a back parenthesis,
				// and preceding operator from the same operators collection has not got
				// a back parentheses.

				// Hemen elemento baten barnean ea parentesia eta operazionala dagoen begiratzen
				// dugu.
				// Adeptness.xtext-en AbstractElement2 begiratzen baduzu op lista bat da non
				// operazionalak,logikoak eta parentesiak dauden
				// ordun parentesi baten aurretik parentesia ez den elementu bat badago errorea
				// ematen du
				// Adibideak: <) edo &&) eta holakoak errorea ematea
				if (j > 0 && elements.getOp().get(j).getBackParentheses() != null
						&& elements.getOp().get(j - 1).getBackParentheses() == null) {
					error("You can't concatenate operators this way",
							AdeptnessPackage.Literals.EXPRESSIONS_MODEL__ELEMENTS);
				}
				// Hemen aurrekoan berdina begiratzen da baina parentesiak ez badira, adibidez +
				// && errorea eman beharko luke
				if (j > 0 && elements.getOp().get(j).getBackParentheses() == null
						&& elements.getOp().get(j - 1).getBackParentheses() == null) {
					error("You can't concatenate operators this way",
							AdeptnessPackage.Literals.EXPRESSIONS_MODEL__ELEMENTS);
				}
			}
		}
		if (conOpenPar != conClosePar) {
			error("Parentheses are not correctly opened and closed",
					AdeptnessPackage.Literals.EXPRESSIONS_MODEL__ELEMENTS);
		}

	}

	@Check
	public void checkWhileConditions(While data) {
		int contLogicOp = 0, contCompOp = 0;
		for (int i = 0; i < data.getEm().getElements().size(); i++) {
			AbstractElement2 element = data.getEm().getElements().get(i);
			for (int j = 0; j < element.getOp().size(); j++) {
				if (element.getOp().get(j).getLogicOperator() != null) {
					contLogicOp++;
				} else if (element.getOp().get(j).getComparation() != null) {
					contCompOp++;
				}
			}
		}
		if (contLogicOp + 1 != contCompOp) {
			error("Only conditions are available for while type", AdeptnessPackage.Literals.WHILE__EM);
		}
	}

	@Check
	public void checkWhenConditions(When data) {
		int contLogicOp = 0, contCompOp = 0;
		for (int i = 0; i < data.getEm().getElements().size(); i++) {
			AbstractElement2 element = data.getEm().getElements().get(i);
			for (int j = 0; j < element.getOp().size(); j++) {
				if (element.getOp().get(j).getLogicOperator() != null) {
					contLogicOp++;
				} else if (element.getOp().get(j).getComparation() != null) {
					contCompOp++;
				}
			}
		}
		if (contLogicOp + 1 != contCompOp) {
			error("Only conditions are available for when type", AdeptnessPackage.Literals.WHEN__EM);
		}
	}

	@Check
	public void checkChecksCondition(Checks check) {
		for (int i = 0; i < check.getEm().getElements().size(); i++) {
			AbstractElement2 element = check.getEm().getElements().get(i);
			for (int j = 0; j < element.getOp().size(); j++) {
				if (element.getOp().get(j).getLogicOperator() != null) {
					error("The operator: " + element.getOp().get(j).getLogicOperator().getOp().toString()
							+ " is not available for checks", AdeptnessPackage.Literals.CHECKS__EM);
				} else if (element.getOp().get(j).getComparation() != null) {
					error("The operator: " + element.getOp().get(j).getComparation().getOp().toString()
							+ " is not available for checks", AdeptnessPackage.Literals.CHECKS__EM);
				}
			}
		}
	}

	@Check
	public void checkAtLeastTime(At_least atLeast) {
		if (atLeast.getTime().getDVal() < 0) {
			error("This value: " + atLeast.getTime().getDVal() + " must be a positive value",
					AdeptnessPackage.Literals.AT_LEAST__TIME);
		}
	}

	@Check
	public void checkAtMostTime(At_most atMost) {
		if (atMost.getTime().getDVal() < 0) {
			error("This value: " + atMost.getTime().getDVal() + " must be a positive value",
					AdeptnessPackage.Literals.AT_MOST__TIME);
		}
	}

	@Check
	public void checkExactlyTime(Exactly exactly) {
		if (exactly.getTime().getDVal() < 0) {
			error("This value: " + exactly.getTime().getDVal() + " must be a positive value",
					AdeptnessPackage.Literals.EXACTLY__TIME);
		}
	}

	@Check
	public void checkEmptyLowerValue(Lower lower) {
		if (lower.getBound_lower().getValue() == null && lower.getBound_lower().getEm() == null) {
			error("Lower bound must have a value or an expression", AdeptnessPackage.Literals.LOWER__BOUND_LOWER);

		}
	}

	@Check
	public void checkEmptyUpperValue(Upper upper) {
		if (upper.getBound_upp().getValue() == null && upper.getBound_upp().getEm() == null) {
			error("Upper bound must have a value or an expression", AdeptnessPackage.Literals.UPPER__BOUND_UPP);

		}
	}

	@Check
	public void checkEmptyBoundsValues(Range range) {
		if (range.getBound_lower().getValue() == null && range.getBound_lower().getEm() == null) {
			error("Lower bound must have a value or an expression", AdeptnessPackage.Literals.RANGE__BOUND_LOWER);

		}
		if (range.getBound_upp().getValue() == null && range.getBound_upp().getEm() == null) {
			error("Upper bound must have a value or an expression", AdeptnessPackage.Literals.RANGE__BOUND_UPP);

		}
	}

	@Check
	public void checkEmptyBoundsValues(Gap gap) {
		if (gap.getBound_lower().getValue() == null && gap.getBound_lower().getEm() == null) {
			error("Lower bound must have a value or an expression", AdeptnessPackage.Literals.GAP__BOUND_LOWER);

		}
		if (gap.getBound_upp().getValue() == null && gap.getBound_upp().getEm() == null) {
			error("Upper bound must have a value or an expression", AdeptnessPackage.Literals.GAP__BOUND_UPP);

		}
	}

	@Check
	public void checkLowerUpperBounds(Range range) {
		if (range.getBound_lower().getValue() != null && range.getBound_upp().getValue() != null) {
			if (range.getBound_lower().getValue().getDVal() > range.getBound_upp().getValue().getDVal()) {
				// TODO should be AdeptnessPackage.Literals.REFERENCE__RANGE, not only
				// lowerbound.
				error("Lower bound can't be higher than upper bound", AdeptnessPackage.Literals.RANGE__BOUND_LOWER);
			}
		} else {
			System.out.println(
					"TODO: check ExpressionsModel to check if lower bound is really lower than upper bound in a range");
		}
	}

	@Check
	public void checkLowerUpperBounds(Gap gap) {
		if (gap.getBound_lower().getValue() != null && gap.getBound_upp().getValue() != null) {
			if (gap.getBound_lower().getValue().getDVal() > gap.getBound_upp().getValue().getDVal()) {
				// TODO should be AdeptnessPackage.Literals.REFERENCE__GAP, not only lowerbound.
				error("Lower bound can't be higher than upper bound", AdeptnessPackage.Literals.GAP__BOUND_LOWER);
			}
		} else {
			System.out.println(
					"TODO: check ExpressionsModel to check if lower bound is really lower than upper bound in a gap");
		}
	}

	@Check
	public void checkEmptyLowerValue(Same same) {
		if (same.getBound_upp().getValue() == null && same.getBound_upp().getEm() == null) {
			error("Upper bound must have a value or an expression", AdeptnessPackage.Literals.SAME__BOUND_UPP);
		}
	}

	@Check
	public void checkEmptyLowerValue(NotSame notSame) {
		if (notSame.getBound_upp().getValue() == null && notSame.getBound_upp().getEm() == null) {
			error("Upper bound must have a value or an expression", AdeptnessPackage.Literals.NOT_SAME__BOUND_UPP);

		}
	}

	@Check
	public void checkValues(DOUBLE value) {
		if (value.getDVal() > 9999999 || value.getDVal() < -9999999) {
			error("This is an invalid value, must be bigger than -9999999 and lower than 9999999",
					AdeptnessPackage.Literals.DOUBLE__DVAL);
		}
	}

	// Oracle specified failure detection in operational data
	// Only one bound specified: upper, lower, equal
	public boolean checkOperationalDataOutOfBounds(ArrayList<Double> operationalData, String type, Double lowBound,
			int during, int times) {
		return checkOperationalDataOutOfBounds(operationalData, type, lowBound, 0.0, during, times);
	}

	public boolean checkOperationalDataOutOfBounds(ArrayList<Double> operationalData, String type, Double lowBound,
			Double upBound, int during, int times) {
		System.out.println(
				"Check if " + times + " out of bounds during " + during + "[" + lowBound + ", " + upBound + "]");
		if ((type.equals("inBetween") || type.equals("notInBetween")) && lowBound > upBound) {
			error("Confidence value too high.", AdeptnessPackage.Literals.CHECKS__FAIL_REASON);
			return false;
		}
		int outofbounds = 0;
		int countTime = 0;
		for (Double opData : operationalData) {
			if (type.equals("upper") && Utils.checkUpper(lowBound, opData)
					|| type.equals("lower") && Utils.checkLower(lowBound, opData)
					|| type.equals("equal") && Utils.checkEqual(lowBound, opData)
					|| type.equals("notInBetween") && Utils.checkNotInBetween(lowBound, upBound, opData)
					|| type.equals("inBetween") && Utils.checkInBetween(lowBound, upBound, opData)) {
				outofbounds++;
				System.out.println("  " + opData + " " + type + " [" + lowBound + ", " + upBound + "]. Out of bounds: "
						+ outofbounds + ", During: " + countTime);
				if (outofbounds == times) {
					System.out.println("FAILURE DETECTED");
					return true;
				}
			}
			if (countTime == during) {
				countTime = 0;
				outofbounds = 0;
			} else if (outofbounds > 0) {
				countTime++;
			}
		}
		return false;
	}

}

//@Check
//public void checkOracleConfigValues(Oracle oracle, Signal CPS) {
//	System.out.println("check OracleConfig  Values entering");
//	boolean is=false;
//	double max, min;
//	int j=0;
//	for (int z=0; z<oracle.getCheck().size(); z++) {
//		is=false;
//		j=0;
//		while(!is && j<CPS.getSuperType().getMonitoringPlan().size()) {
//			if(oracle.getCheck().get(z).getName().toString().equals(CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getName().toString())) {
//				is=true;
//			}
//			j++;
//		}
//		if(j==CPS.getSuperType().getMonitoringPlan().size() && !is) {
//			error("There is at least one variable not included in the monitoring plan", AdeptnessPackage.Literals.SIGNAL__ORACLE);
//		}
//		else if(is) {
//			j--;
//			if(!CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMonitoringVariableDatatype().getSig_type().equals("boolean")) {
//				max=CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMax().getDVal();
//				min=CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMin().getDVal();
//			}
//			else {
//				max=1;
//				min=0;
//			}
//				if(oracle.getCheck().get(z).getReference().getUpper()!=null) {
//					Upper up=oracle.getCheck().get(z).getReference().getUpper();
//					if(up.getBound_upp().getValue().getDVal()>max ||up.getBound_upp().getValue().getDVal()>min) {
//						System.out.println("A");
//						error("Every reference must be between max and min values",AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//				else if(oracle.getCheck().get(z).getReference().getLower()!=null) {
//					Lower low=oracle.getCheck().get(z).getReference().getLower();
//					if(low.getBound_lower().getValue().getDVal()>max ||low.getBound_lower().getValue().getDVal()>min) {
//						System.out.println("B");
//						error("Every reference must be between max and min values",AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//				else if(oracle.getCheck().get(z).getReference().getGap()!=null) {
//					Gap gap=oracle.getCheck().get(z).getReference().getGap();
//					if(gap.getBound_upp().getValue().getDVal()>max || gap.getBound_upp().getValue().getDVal()<min || gap.getBound_lower().getValue().getDVal()>max ||gap.getBound_lower().getValue().getDVal()<min) {
//						System.out.println("C");
//						error("Every reference must be between max and min values",AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//				else if(oracle.getCheck().get(z).getReference().getRange()!=null) {
//					Range range=oracle.getCheck().get(z).getReference().getRange();
//					if(range.getBound_upp().getValue().getDVal()>max || range.getBound_upp().getValue().getDVal()<min || range.getBound_lower().getValue().getDVal()>max ||range.getBound_lower().getValue().getDVal()<min) {
//						System.out.println("D");
//						error("Every reference must be between max and min values",AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//		}
//	}
//	
//}
//
//@Check
//public void checkCPSConfigValues(Signal CPS) {
//	System.out.println("check checkCPSConfigValues entering");
//	boolean is=false;
//	double max, min;
//	int j=0;
//	for(int i=0; i<CPS.getOracle().size(); i++) {
//		for (int z=0; z<CPS.getOracle().get(i).getCheck().size(); z++) {
//			is=false;
//			j=0;
//			while(!is && j<CPS.getSuperType().getMonitoringPlan().size()) {
//				if(CPS.getOracle().get(i).getCheck().get(z).getName().toString().equals(CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getName().toString())) {
//					is=true;
//				}
//				j++;
//			}
//			if(j==CPS.getSuperType().getMonitoringPlan().size() && !is) {
//				String errorString = "The variable " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " is not in the monitoring plan";
//				error(errorString, AdeptnessPackage.Literals.SIGNAL__ORACLE);
//			}
//			else if(is) {
//				j--;
//				if(!CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMonitoringVariableDatatype().getSig_type().equals("boolean")) {
//					max=CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMax().getDVal();
//					min=CPS.getSuperType().getMonitoringPlan().get(j).getMonitoringVariables().getMin().getDVal();
//				}
//				else {
//					max=1;
//					min=0;
//				}
//				if(CPS.getOracle().get(i).getCheck().get(z).getReference().getUpper()!=null) {
//					Upper up=CPS.getOracle().get(i).getCheck().get(z).getReference().getUpper();
//					if(up.getBound_upp().getValue().getDVal()>max) {
//						System.out.println("A");
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply max values specified in the validation plan insede the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);//SIGNAL__ORACLE
//					}
//					if(up.getBound_upp().getValue().getDVal()<min) {
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply min values specified in the validation plan insede the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);//SIGNAL__ORACLE
//
//					}
//				}
//				else if(CPS.getOracle().get(i).getCheck().get(z).getReference().getLower()!=null) {
//					Lower low=CPS.getOracle().get(i).getCheck().get(z).getReference().getLower();
//					if(low.getBound_lower().getValue().getDVal()>max) {
//						System.out.println("B");
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply max values specified in the validation plan in the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//					if(low.getBound_lower().getValue().getDVal()<min) {
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply min values specified in the validation plan in the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);
//			
//					}
//				}
//				else if(CPS.getOracle().get(i).getCheck().get(z).getReference().getGap()!=null) {
//					Gap gap=CPS.getOracle().get(i).getCheck().get(z).getReference().getGap();
//					if(gap.getBound_upp().getValue().getDVal()>max || gap.getBound_upp().getValue().getDVal()<min || gap.getBound_lower().getValue().getDVal()>max ||gap.getBound_lower().getValue().getDVal()<min) {
//						System.out.println("C");
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply max and/or min values in the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//				else if(CPS.getOracle().get(i).getCheck().get(z).getReference().getRange()!=null) {
//					Range range=CPS.getOracle().get(i).getCheck().get(z).getReference().getRange();
//					if(range.getBound_upp().getValue().getDVal()>max || range.getBound_upp().getValue().getDVal()<min || range.getBound_lower().getValue().getDVal()>max ||range.getBound_lower().getValue().getDVal()<min) {
//						System.out.println("D");
//						String errorString = "Oracle " + CPS.getOracle().get(i).getCheck().get(z).getName().toString() + " does not comply max and/or min values in the check";
//						error(errorString,AdeptnessPackage.Literals.SIGNAL__ORACLE);
//					}
//				}
//			}
//		}
//	}
//}

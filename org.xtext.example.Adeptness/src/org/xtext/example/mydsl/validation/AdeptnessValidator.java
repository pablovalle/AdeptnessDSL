/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.validation;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ComposedChecks;
import org.xtext.example.mydsl.adeptness.AdeptnessPackage;
import org.xtext.example.mydsl.adeptness.CustomOracle;
import org.xtext.example.mydsl.adeptness.Description;
import org.xtext.example.mydsl.adeptness.InferMonitoringFile;
import org.xtext.example.mydsl.adeptness.ModelFile;
import org.xtext.example.mydsl.adeptness.MonitoringFile;
import org.xtext.example.mydsl.adeptness.MonitoringInferVariables;
import org.xtext.example.mydsl.adeptness.MonitoringVariable;
import org.xtext.example.mydsl.adeptness.NonTrainableModel;
import org.xtext.example.mydsl.adeptness.Oracle;
import org.xtext.example.mydsl.adeptness.Signal;
import org.xtext.example.mydsl.adeptness.TrainableModel;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators= { OracleAssesment.class, UncertaintyValidator.class })
public class AdeptnessValidator extends AbstractAdeptnessValidator {
	public static String DUPLICATED_NAME = "Duplicated Name";

	double cantHigh;
	double cantTime;
	double cantDeg;
	double cantXPeak;

	List<String> oracleNames;
	List<String> monitoringVariableNames;
	List<String> inferenceVariableNames;
	List<String> models;
	List<String> independentVariables;

	MonitoringVariables monitoringVariables;

	// GET MONITORING VARIABLES
	@Check
	public void getImportedMonitoringVariables(Signal CPS) {
		monitoringVariables = MonitoringVariables.getInstance(CPS.getName());

		String type, name;
		double min, max;
		Set<String> monitoringVars = new HashSet<String>();
		for (int i = 0; i < CPS.getSuperType().getMonitoringPlan().size(); i++) {
			MonitoringVariable monitor = CPS.getSuperType().getMonitoringPlan().get(i).getMonitoringVariables();
			name = monitor.getName().toString();
			monitoringVars.add(name);
			type = monitor.getMonitoringVariableDatatype().getSig_type().toString();
			if (type.equals("boolean")) {
				max = 1;
				min = 0;
			} else {
				max = monitor.getMax().getDVal();
				min = monitor.getMin().getDVal();
			}
			monitoringVariables.addVariable(CPS.getName(), name, type, max, min);
		}

		for (int i = 0; i < CPS.getSuperTypeInfer().getMonitoringInferVariables().size(); i++) {
			MonitoringInferVariables monitor = CPS.getSuperTypeInfer().getMonitoringInferVariables().get(i);
			name = monitor.getName().toString();
			monitoringVars.add(name);
			type = monitor.getMonitoringVariableDatatype().getSig_type().toString();
			if (type.equals("boolean")) {
				max = 1;
				min = 0;
			} else {
				max = monitor.getMax().getDVal();
				min = monitor.getMin().getDVal();
			}
			monitoringVariables.addVariable(CPS.getName(), name, type, max, min);
		}

		// remove unused vars
		Set<String> varNames = new HashSet<>(monitoringVariables.getVarNames());
		for (String varName : varNames) {
			if (!monitoringVars.contains(varName)) {
				monitoringVariables.removeVariable(varName);
			}
		}
	}

	@Check
	public void getMonitoringVariablesNames(MonitoringFile file) {
		monitoringVariableNames = new ArrayList<>();
		
		for (int i = 0; i < file.getMonitoringPlan().size(); i++) {
			monitoringVariableNames.add(file.getMonitoringPlan().get(i).getMonitoringVariables().getName().toString());
		}
	}
	
	@Check
	public void getInferNames(InferMonitoringFile file) {
		inferenceVariableNames = new ArrayList<>();
		models = new ArrayList<>();

		for (int i = 0; i < file.getMonitoringInferVariables().size(); i++) {
			inferenceVariableNames.add(file.getMonitoringInferVariables().get(i).getName().toString());
		}

		for (int i = 0; i < file.getSuperType().getNonTrainableModel().size(); i++) {
			models.add(file.getSuperType().getNonTrainableModel().get(i).getName());
		}
		
		for (int i = 0; i< file.getSuperType().getTrainableModel().size(); i++) {
			models.add(file.getSuperType().getTrainableModel().get(i).getName());
		}
	}
	
	@Check
	public void getIndependentVariables(ModelFile file) {
		independentVariables = new ArrayList<>();
		for (int i = 0; i < file.getSuperType().getMonitoringPlan().size(); i++) {
			independentVariables.add(file.getSuperType().getMonitoringPlan().get(i).getMonitoringVariables().getName());
		}
	}

	@Check
	public void checkDuplicatedMonitoringVariableNames(MonitoringVariable variable) {
		String name = variable.getName().toString();
		int cont = 0;
		for (int i = 0; i < monitoringVariableNames.size(); i++) {
			if (monitoringVariableNames.get(i).toString().equals(name)) {
				cont++;
				if (cont > 1) {
					error("Monitoring Variables' name must be unique",
							AdeptnessPackage.Literals.MONITORING_VARIABLE__NAME, DUPLICATED_NAME);
					break;
				}
			}
		}
		for (int i = 0; i < inferenceVariableNames.size(); i++) {
			if (inferenceVariableNames.get(i).toString().equals(name)) {
				cont++;
				if (cont > 1) {
					error("Monitoring Variables' name must be unique",
							AdeptnessPackage.Literals.MONITORING_VARIABLE__NAME, DUPLICATED_NAME);
					break;
				}
			}
		}
	}

	@Check
	public void checkDuplicatedInferenceVariableNames(MonitoringInferVariables variable) {
		String name = variable.getName().toString();
		int cont = 0;
		for (int i = 0; i < monitoringVariableNames.size(); i++) {
			if (monitoringVariableNames.get(i).toString().equals(name)) {
				cont++;
				if (cont > 1) {
					error("Monitoring Variables' name must be unique",
							AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__NAME, DUPLICATED_NAME);
					break;
				}
			}
		}
		for (int i = 0; i < inferenceVariableNames.size(); i++) {
			if (inferenceVariableNames.get(i).toString().equals(name)) {
				cont++;
				if (cont > 1) {
					error("Monitoring Variables' name must be unique",
							AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__NAME, DUPLICATED_NAME);
					break;
				}
			}
		}
	}

	@Check
	public void getOraclesNames(Signal CPS) {
		oracleNames = new ArrayList<>();
		for (int i = 0; i < CPS.getOracle().size(); i++) {
			oracleNames.add(CPS.getOracle().get(i).getName().toString());
		}
	}

	@Check
	public void checkDuplicatedOracleNames(Oracle oracle) {
		String name = oracle.getName().toString();
		int cont = 0;
		for (int i = 0; i < oracleNames.size(); i++) {
			if (oracleNames.get(i).toString().equals(name)) {
				cont++;
			}
		}
		if (cont > 1) {
			error("Oracle's name must be unique", AdeptnessPackage.Literals.ORACLE__NAME);
		}
	}

	@Check
	public void checkBooleanMinMaxValidation(MonitoringVariable monitoringVariable) {
		if (monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("boolean")
				&& (monitoringVariable.getMax() != null || monitoringVariable.getMin() != null)) {
			error("A boolean type signal can't have max and min values",
					AdeptnessPackage.Literals.MONITORING_VARIABLE__MONITORING_VARIABLE_DATATYPE);

		} else if ((monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("int")
				|| monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("double"))
				&& (monitoringVariable.getMax() == null || monitoringVariable.getMin() == null)) {
			error("An int or double type signal must have max and min values",
					AdeptnessPackage.Literals.MONITORING_VARIABLE__MONITORING_VARIABLE_DATATYPE);
		}
	}

	@Check
	public void checkBooleanMinMaxValidation(MonitoringInferVariables monitoringVariable) {
		if (monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("boolean")
				&& (monitoringVariable.getMax() != null || monitoringVariable.getMin() != null)) {
			error("A boolean type signal can't have max and min values",
					AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MONITORING_VARIABLE_DATATYPE);

		} else if ((monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("int")
				|| monitoringVariable.getMonitoringVariableDatatype().getSig_type().toString().equals("double"))
				&& (monitoringVariable.getMax() == null || monitoringVariable.getMin() == null)) {
			error("An int or double type signal must have max and min values",
					AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MONITORING_VARIABLE_DATATYPE);
		}
	}

	@Check
	public void checkMinMaxValues(MonitoringVariable monitoringVariable) {
		if (monitoringVariable.getMax().getDVal() < monitoringVariable.getMin().getDVal()) {
			error("Max value must be higher than min value", AdeptnessPackage.Literals.MONITORING_VARIABLE__MAX);
		}
	}

	@Check
	public void checkMinMaxValues(MonitoringInferVariables monitoringVariable) {
		if (monitoringVariable.getMax().getDVal() < monitoringVariable.getMin().getDVal()) {
			error("Max value must be higher than min value", AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MAX);
		}
	}

	@Check
	public void checkInfereceModel(MonitoringInferVariables monitoringVariable) {
		boolean modelDefined = false;
		for (String model : models) {
			if (monitoringVariable.getModel().equals(model)) {
				modelDefined = true;
			}
		}
		if (monitoringVariable.getModel().isEmpty()) {
			error("Model cannot be empty.",
					AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MODEL);
		}else if (!modelDefined) {
			error("Model is not defined in the imported models' file.",
					AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MODEL);
		}else if (!monitoringVariable.getModel().endsWith(".tflite")) {
			error("Model must be of type TensorFlow Lite.",
					AdeptnessPackage.Literals.MONITORING_INFER_VARIABLES__MODEL);
		}
	}
	
	@Check
	public void checkIndepentVariablesInMonitoringFile(NonTrainableModel monitoringVariable) {
		checkVariablesInMonitoringPlan(monitoringVariable.getVariables(), "Independent variables list cannot be empty.",
				AdeptnessPackage.Literals.NON_TRAINABLE_MODEL__VARIABLES);
	}
	
	@Check
	public void checkIndepentVariablesInMonitoringFile(TrainableModel monitoringVariable) {
		checkVariablesInMonitoringPlan(monitoringVariable.getVariables(), "Independent variables list cannot be empty.",
				AdeptnessPackage.Literals.TRAINABLE_MODEL__VARIABLES);
	}
	
	@Check
	public void checkModelLastLayer(TrainableModel tm) {
		if (tm.getLayers().get(tm.getLayers().size() - 1).getDense().getUnits() != 1) {
			error("Last layer's units must be 1.", AdeptnessPackage.Literals.TRAINABLE_MODEL__LAYERS);
		}
		if (tm.getDataFile().isBlank()) {
			error("Data file cannot be empty.", AdeptnessPackage.Literals.TRAINABLE_MODEL__DATA_FILE);
		}
	}
	
//	@Check
//	public void checkActivation(Layer layer) {
//		if (layer.getDense().getActivation().isEmpty()) {
//			error("Activation cannot be empty.", AdeptnessPackage.Literals.LAYER__DENSE);
//		}
//	}
	
	@Check
	public void checkEmptyDescription(Description desc) {
		if (desc.getValue() == null) {
			error("Description cannot be empty", AdeptnessPackage.Literals.DESCRIPTION__VALUE);
		}
	}

	@Check
	public void checkCustomOracle(CustomOracle cuOr) {
		if (cuOr.getPrecondition() != null) {
			if (cuOr.getPredInputs() == null) {
				error("Precondition inputs must be set if a precondition is defined.",
						AdeptnessPackage.Literals.CUSTOM_ORACLE__PRECONDITION);
				return;
			}else {
				boolean emptyError = checkVariablesInMonitoringPlan(cuOr.getPredInputs(),
						"Precondition input variables list cannot be empty.",
						AdeptnessPackage.Literals.CUSTOM_ORACLE__PRED_INPUTS);
				if (emptyError) {
					return;
				}
			}
		}

		if (cuOr.getCheckInputs() == null) {
			error("Must define a checks input variable list", AdeptnessPackage.Literals.CUSTOM_ORACLE__CHECK_INPUTS);
		} else {
			checkVariablesInMonitoringPlan(cuOr.getCheckInputs(), "Checks input variables list cannot be empty.",
					AdeptnessPackage.Literals.CUSTOM_ORACLE__CHECK_INPUTS);
		}
	}

	// PRIVATE FUNCTIONS
	private boolean checkVariablesInMonitoringPlan(EList<String> variables, String emptyErrorMessage,
			EAttribute reference) {
		if (variables.size() == 0) {
			error(emptyErrorMessage, reference);
			return true;
		}

		for (int i = 0; i < variables.size(); i++) {
			String name = variables.get(i);

			if (!independentVariables.contains(name)) {
				error("Variable " + name + " is not in the monitoring plan", reference);
			}
		}
		return false;
	}

}

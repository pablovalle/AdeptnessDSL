grammar org.xtext.example.mydsl.Adeptness with org.eclipse.xtext.common.Terminals

generate adeptness "http://www.xtext.org/example/mydsl/Adeptness"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Adeptness:
	(elements+=AbstractElement)*
;

AbstractElement:
	PackageDeclaration | Type | Imports
;

Imports:
	'import' importedNamespace=QualifiedNameWithWildcard
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

QualifiedName:
	ID ('.' ID)*
;

Type:
	DataType | Signal | MonitoringFile
;

MonitoringFile:
	'MONITORINGPLAN' name=ID ':'
		(monitoringPlan+=MonitoringPlan)+'ENDMONITORINGPLAN'
		/*(check_static_upper+=Check_Static_upper_only)*
		(check_static_lower+=Check_Static_lower_only)*
		(check_range+=Check_Range)*
		(check_gap+=Check_Gap)*/
;


MonitoringPlan:
	monitoringVariables = MonitoringVariable 
	
;

/*MonitoringVariable: 
 //'MonitoringVariable' '{'
	(monitoringVariable+=MonVar)*	
  //'}';	*/
MonitoringVariable: 
	'MONITOR' name=ID ':'
		'type'':' (MonitoringVariableDatatype = Sig_type)
		('max'':' max = DOUBLE
		'min'':' min = DOUBLE)?
		//(monvar+=MonVar)+
		'ENDMONITOR'
;	


/*MonVar:
	//'sig:' name = ID'{'
		'type:' MonitoringVariableDatatype = Sig_type
		//'signalPattern:' sigPattern = SigPattern
		//('unit:' unit = STRING)?
		('max:' max = DOUBLE
		'min:' min = DOUBLE)?
		//('timePeriod:' timePeriod_down = DOUBLE 'to' timePeriod_up = DOUBLE)?
	//'}'
;*/

Sig_type:
	((sig_type = 'boolean')|(sig_type = 'int' )|(sig_type = 'double' ))
;

//Each signal could have more than one oracles
Signal:
	//imp = ImportMonitoringPlan
	'CPS' name=ID ('[' cardinalityNumCPS = INT ']')? ':' ('implements'superType=[MonitoringFile|QualifiedName])?
		(oracle+=Oracle)+'ENDCPS'
		/*(check_static_upper+=Check_Static_upper_only)*
		(check_static_lower+=Check_Static_lower_only)*
		(check_range+=Check_Range)*
		(check_gap+=Check_Gap)*/
;

ImportMonitoringPlan:
	'import' importURI = STRING
;

Oracle: 
	'ORACLE' name=ID ':'
		(check+=Checks)+'ENDORACLE'
;

Checks:
	'checks:' name=STRING //'is'
	(reference=Reference)
	(failReason+=FailReason)+
	(description=Description) //','
	
;

Description:
	'Description: ' value=STRING
;

FailReason:
	'fails if :'
	(reason=Reason)
	
;

Reason:
	((highPeak=HighPeak)|(highTime=HighTime)|(constDeg=ConstDeg)|(xPeaks=XPeaks)) ';'
;

XPeaks:
	'confidence is below' (cant=DOUBLE) 'more than' (nPeaks=DOUBLE) 'times within' (time=INT) (unit=TimeType) //nola jarri integer-ak?
;

ConstDeg:
	'confidence is in constant degradation'  (cant=DOUBLE) //(((upper=Upper)|(lower=Lower)))
;

HighTime:
	'confidence is below' (cant=DOUBLE) 'within' (time=DOUBLE) (unit=TimeType)
;

HighPeak:
	'confidence is below' (cant=DOUBLE)
;
Reference:
	((upper=Upper)|(lower=Lower)|(range=Range)|(gap=Gap))';'
;
//Oracle for upper limit --> Below reference signal
Upper:
	'is below' (bound_upp=Bound_up)
;
//Oracle for lower limit --> Above reference signal
Lower:
	'is above' (bound_lower=Bound_Down)
;
//Oracle for Above and Below limit --> In range reference signal
Range:
	'is in range between' (bound_lower=Bound_Down) 'and' (bound_upp=Bound_up)
;
//Oracle for !Above and !Below limit --> Gap reference signal
Gap:
	'not in range between' (bound_lower=Bound_Down) 'and' (bound_upp=Bound_up)
;

//If the limits must be included ==
InclusiveBound:
	'inclusiveBound' name=ID '=' value= BOOLEAN
;
//Upper limit

Bound_up:
	value=DOUBLE
;
//Lower limit
Bound_Down:
	 value=DOUBLE
;
//Boolean declaration
BOOLEAN:
	bool=b	
;
b returns ecore::EBoolean: 'true' | 'false';
//Double declaration
DOUBLE:
	dVal = d
;
d returns ecore::EDouble : ('-')? INT('.'INT)?;


TimeType:
	((time='miliseconds')|(time='seconds')|(time='minutes')|(time='hours'))
;

//DataType declaration
DataType:
	'datatype' name=ID
;
//Package declaration
PackageDeclaration:
	'package' name=QualifiedName '{'
		(elements+=AbstractElement)*
	'}'	
;

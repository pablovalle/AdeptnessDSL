/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import org.xtext.example.mydsl.adeptness.Signal
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.example.mydsl.adeptness.Oracle
import org.eclipse.emf.common.util.EList
import org.xtext.example.mydsl.adeptness.Checks
import java.util.ArrayList
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AdeptnessGenerator extends AbstractGenerator {
 @Inject extension IQualifiedNameProvider

	//Poner el directorio de la seinal, donde se van a generar los .c y .h para poder compilarlo en matlab y generar el .mex file
	//String directory="C:\\Users\\hazibek02\\runtime-EclipseXtext\\Matlab\\src-gen\\lehenengoa\\"; 

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    	//fsa.generateFile("adeptness.xml", resource.allContents.toIterable.filter(Signal).createXML());
      		for(e: resource.allContents.toIterable.filter(Signal)){
       	
			/*for(f: e.check_range){
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".c", f.create_range_c())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".h", f.create_range_h())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".m", f.create_range_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+f.name.toString+"')");
			}
			for (u: e.check_gap){
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".c", u.create_gap_c())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".h", u.create_gap_h())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".m", u.create_gap_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+u.name.toString+"')");
			}
			for(l: e.check_static_lower){
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".c", l.create_low_c())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".h", l.create_low_h())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".m", l.create_low_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+l.name.toString+"')");
			}
			for(d: e.check_static_upper){
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".c", d.create_up_c())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".h", d.create_up_h())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".m", d.create_up_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}*/
			for(q: e.oracle){
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".c", q.create_oracle_c())
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".h", q.create_oracle_h())
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".m", q.create_oracle_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}
			
		}
    }
	
	/*def createXML(Iterable<Signal> signals)'''
	<?xml version='1.0' encoding="UTF-8"?>
		«FOR s : signals»
			<Signal>
				<SignalDescription name="«s.fullyQualifiedName.toString("/")»">
					<TypeSignalDescription name="Static">
						«FOR c: s.check_gap»
							<Type name="«c.name.toString»">
								<Parameters>
									<«c.inclusive_bound.eClass.name.toString()»>«c.inclusive_bound.value.bool»</«c.inclusive_bound.eClass.name.toString()»>
									<«c.bound_up.eClass.name.toString()»>«c.bound_up.value.DVal»</«c.bound_up.eClass.name.toString()»>
									<«c.bound_low.eClass.name.toString()»>«c.bound_low.value.DVal»</«c.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Low">
						«FOR l: s.check_static_lower»
							<Type name="«l.name.toString»">
								<Parameters>
									<«l.inclusive_bound.eClass.name.toString()»>«l.inclusive_bound.value.bool»</«l.inclusive_bound.eClass.name.toString()»>
									<«l.bound_low.eClass.name.toString()»>«l.bound_low.value.DVal»</«l.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Up">
						«FOR u: s.check_static_upper»
							<Type name="«u.name.toString»">
								<Parameters>
									<«u.inclusive_bound.eClass.name.toString()»>«u.inclusive_bound.value.bool»</«u.inclusive_bound.eClass.name.toString()»>
									<«u.bound_up.eClass.name.toString()»>«u.bound_up.value.DVal»</«u.bound_up.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Dynamic">
						«FOR d: s.check_range»
							<Type name="«d.name.toString»">
								<Parameters>
									<«d.inclusive_bound.eClass.name.toString()»>«d.inclusive_bound.value.bool»</«d.inclusive_bound.eClass.name.toString()»>
									<«d.bound_up.eClass.name.toString()»>«d.bound_up.value.DVal»</«d.bound_up.eClass.name.toString()»>
									<«d.bound_low.eClass.name.toString()»>«d.bound_low.value.DVal»</«d.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>		
						«ENDFOR»
					</TypeSignalDescription>						
				</SignalDescription>
			</Signal>
		«ENDFOR»
	'''*/
	
	
	def create_oracle_m(Oracle param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	def create_oracle_h(Oracle param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	«FOR param1: param.check»
	«IF param1.name!==null»
		«IF param1.reference.upper!==null»
		struct Ret{
			int assert;
			double diff;
		};
		struct Ret BelowReference (double «param1.name.toString()»[], double timeStamp[]);
		«ELSEIF param1.reference.lower!==null»
		struct Ret{
			int assert;
			double diff;
		};
		struct Ret AboveReference (double «param1.name.toString()»[], double timeStamp[]);
		«ELSEIF param1.reference.range!==null»
		struct Ret{
			int assert;
			double diff_up;
			double diff_down;
		};
		struct Ret RangeReference (double «param1.name.toString()»[], double timeStamp[]);
		«ELSEIF param1.reference.gap!==null»
		struct Ret{
			int assert;
			double diff_up;
			double diff_down;
		};
		struct Ret GapReference (double «param1.name.toString()»[], double timeStamp[]);
		«ENDIF»
	«ELSE»
	«var cont=0»
	«IF param1.reference.upper!==null»
		struct Ret{
			int assert;
			double diff;
		};
		struct Ret BelowReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]);
		«ELSEIF param1.reference.lower!==null»
		struct Ret{
			int assert;
			double diff;
		};
		struct Ret AboveReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]);
		«ELSEIF param1.reference.range!==null»
		struct Ret{
			int assert;
			double diff_up;
			double diff_down;
		};
		struct Ret RangeReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]);
		«ELSEIF param1.reference.gap!==null»
		struct Ret{
			int assert;
			double diff_up;
			double diff_down;
		};
		struct Ret GapReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]);
	«ENDIF»
	«ENDIF»
	«ENDFOR»
	
	#endif
	'''	
	def create_oracle_c(Oracle param)'''
	#include "«param.name.toString()».h"
	«FOR param1: param.check»
		«IF param1.name!==null»
		«IF param1.reference.upper!==null»
		struct Ret BelowReference (double «param1.name.toString()», double timeStamp[]){
		«ELSEIF param1.reference.lower!==null»
		struct Ret AboveReference (double «param1.name.toString()», double timeStamp[]){
		«ELSEIF param1.reference.range!==null»
		struct Ret RangeReference (double «param1.name.toString()», double timeStamp[]){
		«ELSEIF param1.reference.gap!==null»
		struct Ret GapReference (double «param1.name.toString()», double timeStamp[]){
		«ENDIF»
				struct Ret ret;
				return ret;
			}		
		«ELSE»
		«IF param1.reference.upper!==null»
		struct Ret BelowReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]){
		«ELSEIF param1.reference.lower!==null»
		struct Ret AboveReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]){
		«ELSEIF param1.reference.range!==null»
		struct Ret RangeReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]){
		«ELSEIF param1.reference.gap!==null»
		struct Ret GapReference («FOR name:param1.em.elements»«IF name.name!==null»double «name.name.toString»[] , «ENDIF»«ENDFOR» double timeStamp[]){
		«ENDIF»
				struct Ret ret;
				return ret;
			}		
		«ENDIF»
	«ENDFOR»
	'''
	
	/*def create_oracle_c(Oracle param)'''
	#include "«param.name.toString()».h"
	«FOR param1: param.check»
		//Comment: «param1.description.value.toString»'''
		«IF param1.reference.upper!==null»
		struct Ret BelowReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.upper.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.value.DVal»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.name.toString»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ELSEIF param1.reference.lower!==null»
		struct Ret AboveReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.lower.bound_lower.value!==null»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.value.DVal»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.name.toString»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.range!==null»
		struct Ret RangeReference (double «param1.name.toString»){
			struct Ret ret;
			
			«IF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSEIF param1.reference.range.bound_lower.value===null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ELSEIF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value===null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.gap!==null»
		struct Ret GapReference (double «param1.name.toString()»){
			struct Ret ret;
			«IF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value===null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value===null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ENDIF»
			return ret;
		}
	«ENDFOR»
		

	'''*/
	

	
	/*def create_up_m(Check_Static_upper_only param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	def create_up_h(Check_Static_upper_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_up_c(Check_Static_upper_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <=«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input <«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''
	
	def create_low_m(Check_Static_lower_only param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_low_h(Check_Static_lower_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_low_c(Check_Static_lower_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal»){
				ret=1;
			}
		«ENDIF»
		return ret;
	}
	'''
	
	def create_range_m(Check_Range param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_range_h(Check_Range param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_range_c(Check_Range param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal» && Input <= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal» && Input < «param.bound_up.value.DVal» ){
						ret=1;
			}	
		«ENDIF»
		return ret;		
			
	}
	'''
	
	def create_gap_m(Check_Gap param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_gap_h(Check_Gap param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_gap_c(Check_Gap param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <= «param.bound_low.value.DVal» || Input >= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input < «param.bound_low.value.DVal» || Input > «param.bound_up.value.DVal» ){
							ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''*/
}

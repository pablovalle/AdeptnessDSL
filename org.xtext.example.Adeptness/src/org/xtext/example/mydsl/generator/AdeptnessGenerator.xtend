/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import com.google.inject.Inject
import com.oracle.truffle.js.scriptengine.GraalJSEngineFactory
import java.io.File
import java.io.FileNotFoundException
import java.io.FileWriter
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Scanner
import java.util.Set
import javax.script.ScriptException
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.example.mydsl.adeptness.AbstractElement2
import org.xtext.example.mydsl.adeptness.CustomOracle
import org.xtext.example.mydsl.adeptness.FailReason
import org.xtext.example.mydsl.adeptness.MonitoringInferVariables

import org.xtext.example.mydsl.adeptness.MonitoringPlan
import org.xtext.example.mydsl.adeptness.Operators
import org.xtext.example.mydsl.adeptness.Oracle
import org.xtext.example.mydsl.adeptness.Signal
import java.util.HashSet
import java.util.stream.Collectors
import org.xtext.example.mydsl.adeptness.ExpressionsModel
import org.xtext.example.mydsl.adeptness.UncertaintyProb
import org.xtext.example.mydsl.adeptness.UncertaintyAmbiguity
import org.xtext.example.mydsl.adeptness.UncertaintyVagueness


import org.xtext.example.mydsl.adeptness.ModelFile
import org.xtext.example.mydsl.adeptness.TrainableModel


/**
 * Generates code from your model files on save.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AdeptnessGenerator extends AbstractGenerator {
 @Inject extension IQualifiedNameProvider

	//Poner el directorio de la seinal, donde se van a generar los .c y .h para poder compilarlo en matlab y generar el .mex file
	String directory="C:\\Users\\pablo\\OneDrive\\Escritorio\\trabajo\\runtime-EclipseXtext\\Pruebas\\src-gen\\"; 
var HashMap<String, List<String>> nameMap;
var HashMap<String, String> whenMap;
var HashMap<String, String> whileMap;
var HashMap<String, String> whenMap_preconds;
var HashMap<String, String> whileMap_preconds;
var HashMap<String, Double> maxMap;
var HashMap<String, Double> minMap;
var HashMap<String, List<String>> checkVar;
var HashMap<String, EList<String>> modelVarFile;
var HashMap<String, Set<String>>varAndOracles;
var List<String> verdict;
var List<String> first;
var Set<String> predAndCheckInputs;
var CharSequence confCalculationBody;
var List<String> uncerNames;
    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

    	//fsa.generateFile("adeptness.xml", resource.allContents.toIterable.filter(Signal).createXML());
//    		for(a: resource.allContents.toIterable.filter(ValidationPlan)){
//    			fsa.generateFile(a.fullyQualifiedName.toString("/")+".json", a.create_VP_json())
//  
//    		}
      		for(e: resource.allContents.toIterable.filter(Signal)){
			
			modelVarFile= new HashMap();
			nameMap= new HashMap();
			whenMap=new HashMap();
			whileMap= new HashMap();
			whileMap_preconds= new HashMap();
			whenMap_preconds= new HashMap();
			checkVar= new HashMap();
			maxMap= new HashMap();
			minMap= new HashMap();
			uncerNames= getUncer(e);
			getAllNames(e);
			findSignalsMaxMinValues(e);
			if(e.superTypeInfer!==null){
				updateModelVarFile(e.superTypeInfer.superType);
				for(model:e.superTypeInfer.superType.trainableModel){
					fsa.generateFile("models/gen_"+model.name+".py", model.create_model_py())
				}
				for(v:e.superTypeInfer.monitoringInferVariables){
					
					fsa.generateFile(e.name+"/"+v.name+".c",v.create_infer_c())
					fsa.generateFile(e.name+"/"+v.name+".h",v.create_infer_h())
				}
			}
			
			for(q: e.oracle){
				verdict= new ArrayList();
				first= new ArrayList();
				
				q.create_verdict_c(nameMap.get(q.name));
				confCalculationBody=q.confCalculation(nameMap.get(q.name));
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".c", q.create_oracle_c(nameMap.get(q.name)))
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".h", q.create_oracle_h(nameMap.get(q.name),e.fullyQualifiedName.toString()))
				
				//appendFile(e,q.fullyQualifiedName.toString("/")+".c",q.fullyQualifiedName.toString("/")+"_Verdict.c")
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".json", q.create_oracle_json())
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".m", q.create_oracle_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}
			for(co:e.customOracle){
				predAndCheckInputs= new HashSet();
				co.getPredAndCheckInputs();
				fsa.generateFile(co.fullyQualifiedName.toString("/")+".c", co.create_C_oracle_c())
				fsa.generateFile(co.fullyQualifiedName.toString("/")+".h", co.create_C_oracle_h(e.fullyQualifiedName.toString()))
				
			}
			varAndOracles=getVarAndOracles(e);
			fsa.generateFile(e.fullyQualifiedName.toString("/")+".json", e.create_oracle_json())
			fsa.generateFile(e.name+"_Uncer.c", e.create_uncer_c())
			fsa.generateFile(e.name+"_Uncer.h", e.create_uncer_h())
			fsa.generateFile("Array.h", e.create_array_h())
			fsa.generateFile("Array.c", e.create_array_c())
			fsa.generateFile(e.fullyQualifiedName.toString()+".h", e.create_global_h())
			
		}
    }
	
	def getVarAndOracles(Signal signal) {
		var HashMap<String, Set<String>> ret=new HashMap();
		var Set<String> list = new HashSet();
		if(signal.customOracle!==null){
			for(customOracle:signal.customOracle){
				if(customOracle.checkInputs!==null){
					for(input: customOracle.checkInputs){
						if(ret.get(input)!==null){
							list=ret.get(input);
							list.add(customOracle.name);
							ret.put(input,list);
						}
						else{
							list= new HashSet();
							list.add(customOracle.name);
							ret.put(input, list);
						}
					}
				}
				if(customOracle.predInputs!==null){
					for(input: customOracle.predInputs){
						if(ret.get(input)!==null){
							list=ret.get(input);
							list.add(customOracle.name);
							ret.put(input,list);
						}
						else{
							list= new HashSet();
							list.add(customOracle.name);
							ret.put(input, list);
						}
					}
				}
			}
		}
		
		if(signal.oracle!==null){
			for(oracle: signal.oracle){
				if(oracle.when!==null){
					for(expression: oracle.when.em.elements){
						if(expression.name!==null){
							if(ret.get(expression.name)!==null){
								list=ret.get(expression.name);
								list.add(oracle.name);
								ret.put(expression.name,list);
							}
							else{
								list= new HashSet();
								list.add(oracle.name);
								ret.put(expression.name, list);
							}
						}
					}
				}
				else if(oracle.^while!==null){
					for(expression: oracle.^while.em.elements){
						if(expression.name!==null){
							if(ret.get(expression.name)!==null){
								list=ret.get(expression.name);
								list.add(oracle.name);
								ret.put(expression.name,list);
							}
							else{
								list= new HashSet();
								list.add(oracle.name);
								ret.put(expression.name, list);
							}
						}
					}
				}
				if(oracle.check.name===null){
					for(expression: oracle.check.em.elements){
						if(expression.name!==null){
							if(ret.get(expression.name)!==null){
								list=ret.get(expression.name);
								list.add(oracle.name);
								ret.put(expression.name,list);
							}
							else{
								list= new HashSet();
								list.add(oracle.name);
								ret.put(expression.name, list);
							}
						}
					}
				}
				else{
					if(ret.get(oracle.check.name)!==null){
						list=ret.get(oracle.check.name);
						list.add(oracle.name);
						ret.put(oracle.check.name,list);
					}
					else{
						list= new HashSet();
						list.add(oracle.name);
						ret.put(oracle.check.name, list);
					}
				}
				if(oracle.check.reference.gap!==null){
					if(oracle.check.reference.gap.bound_upp.value===null){
						for(expression: oracle.check.reference.gap.bound_upp.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
					if(oracle.check.reference.gap.bound_lower.value===null){
						for(expression: oracle.check.reference.gap.bound_lower.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
				else if(oracle.check.reference.lower!==null){
					if(oracle.check.reference.lower.bound_lower.value===null){
						for(expression: oracle.check.reference.lower.bound_lower.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
				else if(oracle.check.reference.notsame!==null){
					if(oracle.check.reference.notsame.bound_upp.value===null){
						for(expression: oracle.check.reference.notsame.bound_upp.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
				else if(oracle.check.reference.range!==null){
					if(oracle.check.reference.range.bound_upp.value===null){
						for(expression: oracle.check.reference.range.bound_upp.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
					if(oracle.check.reference.range.bound_lower.value===null){
						for(expression: oracle.check.reference.range.bound_lower.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
				else if(oracle.check.reference.same!==null){
					if(oracle.check.reference.same.bound_upp.value===null){
						for(expression: oracle.check.reference.same.bound_upp.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
				else if(oracle.check.reference.upper!==null){
					if(oracle.check.reference.upper.bound_upp.value===null){
						for(expression: oracle.check.reference.upper.bound_upp.em.elements){
							if(expression.name!==null){
								if(ret.get(expression.name)!==null){
									list=ret.get(expression.name);
									list.add(oracle.name);
									ret.put(expression.name,list);
								}
								else{
									list= new HashSet();
									list.add(oracle.name);
									ret.put(expression.name, list);
								}
							}
						}
					}
				}
			}
		}
				
		return ret;
	}
	

	def void getPredAndCheckInputs(CustomOracle oracle){
		if(oracle.precondition!==null){
			for(name: oracle.predInputs){
				predAndCheckInputs.add(name);
			}
		}
		for(name :oracle.checkInputs){
			predAndCheckInputs.add(name);
		}
	}
		
	
	
	
	def confCalculation(Oracle param, List<String> strings)'''
	«IF param.check.reference.upper!==null»
	if(signal<«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf= («IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else{
		conf= («IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.lower!==null»
	if(signal>«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			
		conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	else{
		conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	«ELSEIF param.check.reference.same!==null»
	if(signal==«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=1;
	}
	else if(signal<«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.notsame!==null»
	if(signal==«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=-1;
	}
	else if(signal<«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.range!==null»
	if(signal<«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
		conf=(«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
	}
	else if(signal>«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
		conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
	}
	else if(signal<«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ENDIF»
	'''
	
	
	def updateModelVarFile(ModelFile modelFile) {
		for(model : modelFile.nonTrainableModel){
			modelVarFile.put(model.name, model.variables);
		}
		for(model: modelFile.trainableModel){
			modelVarFile.put(model.name, model.variables);
		}
	}
	
	def create_model_py(TrainableModel model)'''
	import pandas as pd
	import tensorflow as tf
	
	def read_data(data_file_name):
	
	    dataset = pd.read_csv(
	        f'{data_file_name}',
	        na_values='NaN',
	        sep=',',
	        skipinitialspace=True
	    )
	
	    dataset = dataset.dropna()
	
	    return dataset
	
	
	def generate_model(features, labels):
	
	    model = tf.keras.Sequential([
	        tf.keras.layers.InputLayer(input_shape=(features.ndim, )),
	        «FOR layer: model.layers »
	        «IF model.layers.indexOf(layer)!== model.layers.size()-1»
	        tf.keras.layers.«layer.dense.name»(«layer.dense.units»,activation='«layer.dense.activation»'),
	        «ELSE»
	        tf.keras.layers.«layer.dense.name»(«layer.dense.units»,activation='«layer.dense.activation»')
	        «ENDIF»
	        «ENDFOR»
	    ])
	
	    model.compile(
	        loss='mean_absolute_error',
	        optimizer=tf.keras.optimizers.Adam(0.001)
	    )
	
	    model.fit(
	        features,
	        labels,
	        validation_split=0.2,
	        verbose=0,
	        epochs=100
	    )
	
	    return model
	
	
	def convert_model(model):
	
	    converter = tf.lite.TFLiteConverter.from_keras_model(model)
	    # ----------- float16 quantization example ------------
	    # converter.optimizations = [tf.lite.Optimize.DEFAULT]
	    # converter.target_spec.supported_types = [tf.float16]
	    # -----------------------------------------------------
	    tflite_model = converter.convert()
	
	    return tflite_model
	
	
	def main(data_file_name, model_file_name, ind_variables):
	    print(tf.__version__)
	
	    dataset = read_data(data_file_name)
	
	    features = dataset[ind_variables]
	
	    labels = dataset.iloc[: , -1]
	
	    model = generate_model(features, labels)
	    tflite_model = convert_model(model)
	
	    with open(f'{model_file_name}', 'wb') as f:
	        f.write(tflite_model)
	
	
	if __name__ == "__main__":
	    # TODO to be automatically generated according to the Monitoring plan
	    data_file_name = "«model.dataFile»"
	    model_file_name = "«model.name».tflite"
	    ind_variables = [
	        «FOR ind_var: model.variables»
	        «IF model.variables.indexOf(ind_var)!==model.variables.size()-1»
	        "«ind_var»",	        
	        «ELSE»
	        "«ind_var»"
	        «ENDIF»
	        «ENDFOR»
	    ]
	    main(data_file_name, model_file_name, ind_variables)
	'''
	
	def create_infer_c(MonitoringInferVariables plan)'''
	#include "«plan.name.toUpperCase».h"
	#include "tensorflow/lite/c/c_api.h"
	
	void infer_«plan.name.toUpperCase»(SensorInput *inputs){
	
	    float input [«modelVarFile.get(plan.model).size»];
	    float output [1];
	
	    // ------- DSL ---------
	    TfLiteModel* model =
	        TfLiteModelCreateFromFile("./«plan.model».tflite");
	    // ---------------------
	
	    TfLiteInterpreterOptions* options =
	        TfLiteInterpreterOptionsCreate();
	    TfLiteInterpreterOptionsSetNumThreads(options, 1);
	
	    TfLiteInterpreter* interpreter =
	        TfLiteInterpreterCreate(model, options);
	
	    TfLiteInterpreterAllocateTensors(interpreter);
	
	    TfLiteTensor* input_tensor =
	        TfLiteInterpreterGetInputTensor(interpreter, 0);
	
	    // ------- DSL ---------
	    «FOR a:modelVarFile.get(plan.model)»
	    input[«modelVarFile.get(plan.model).indexOf(a)»] = inputs->«a.toString»;
	    «ENDFOR»
	    // ---------------------
	  
	    TfLiteTensorCopyFromBuffer(
	        input_tensor,
	        input,
	        sizeof(input)
	    );
	
	    TfLiteInterpreterInvoke(interpreter);
	
	    const TfLiteTensor* output_tensor =
	        TfLiteInterpreterGetOutputTensor(interpreter, 0);
	    TfLiteTensorCopyToBuffer(
	        output_tensor, output, sizeof(output)
	    );
	
	    // ------- DSL ---------
	    inputs->«plan.name» = output[0];
	    // ---------------------
	
	    TfLiteInterpreterDelete(interpreter);
	    TfLiteInterpreterOptionsDelete(options);
	    TfLiteModelDelete(model);
	
	}
	
	'''
	def create_infer_h(MonitoringInferVariables plan)'''
	#ifndef «plan.name.toUpperCase»_H
	#define «plan.name.toUpperCase»_H
	
	#include "oracle_commons.h"
	
	void infer_«plan.name.toUpperCase»(SensorInput *inputs);
	
	#endif
	'''
	
	def List<String> getUncer(Signal signal) {
		var List<String> uncer= new ArrayList();
		var String name=""
		for(Oracle o: signal.oracle){
			if(o.when!==null && o.when.em!==null){
				for(AbstractElement2 element: o.when.em.elements){
					if(element.uncer1!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer2!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer3!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
				}
			}
			if(o.^while!==null && o.^while.em!==null){
				for(AbstractElement2 element: o.^while.em.elements){
					if(element.uncer1!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer2!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer3!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
				}
			}
			if(o.check!==null && o.check.em!==null){
				for(AbstractElement2 element: o.check.em.elements){
					if(element.uncer1!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer2!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
					else if(element.uncer3!==null){
						name=getUncerType(element);
						if(!name.equals("NO")){
							uncer.add(name);
						}
					}
				}
			}
		}
		uncer=uncer.stream().distinct().collect(Collectors.toList());
		return uncer;
	}
	
	def String getUncerType(AbstractElement2 element) {
		var String ret="NO";
		if(element.uncer1!==null){
			if(element.uncer1.bernoulliDistribution!==null){
				if(element.uncer1.bernoulliDistribution.bernProb!==null){
					ret="BernoulliDistribution_prob";
				}
				else if(element.uncer1.bernoulliDistribution.bernTrials!==null){
					ret="BernoulliDistribution_trials";
				}
				
			}
			else if(element.uncer1.gammaDistribution!==null){
				if(element.uncer1.gammaDistribution.gammaK!==null){
					ret="GammaDistribution_K";
				}
				else if(element.uncer1.gammaDistribution.gammaMean!==null){
					ret="GammaDistribution_mean";
				}
				
			}
			else if(element.uncer1.normalDisstribution!==null){
				if(element.uncer1.normalDisstribution.mean!==null){
					ret="NormalDistribution_mean";
				}
				else if(element.uncer1.normalDisstribution.normDistStd!==null){
					ret="NormalDistribution_normDistStd";
				}
				
			}
			else if(element.uncer1.percentage!==null){
				if(element.uncer1.percentage.valuePer!==null){
					ret="Percentage_value";
				}
			}
		}
		else if(element.uncer2!==null){
			if(element.uncer2.fuzzyInterval!==null){
				if(element.uncer2.fuzzyInterval.maxfuzzyNumber!==null){
					ret="FuzzyInterval_maxfuzzyNumber";
				}
				else if(element.uncer2.fuzzyInterval.minfuzzyNumber!==null){
					ret="FuzzyInterval_minfuzzyNumber";
				}
			}
			else if(element.uncer2.fuzzySetCut!==null){
				if(element.uncer2.fuzzySetCut.fuzzySetCutLam!==null){
					ret="FuzzySetCut_lambda";
				}
				else if(element.uncer2.fuzzySetCut.fuzzySetCutisStr!==null){
					ret="FuzzySetCut_isStrong";
				}
				else if(element.uncer2.fuzzySetCut.fuzzySetCutkin!==null){
					ret="FuzzySetCut_kind";
				}
			}
			else if(element.uncer2.fuzzyLogic!==null){
				if(element.uncer2.fuzzyLogic.fuzzyLogicOpera!==null){
					ret="FuzzyLogic_operator";
				}
				else if(element.uncer2.fuzzyLogic.fuzzyLogicVar!==null){
					ret="FuzzyLogic_var";
				}
				else if(element.uncer2.fuzzyLogic.fuzzyLogicSet!==null){
					if(element.uncer2.fuzzyLogic.fuzzyLogicSet.FLSmembershipDegree!==null){
						ret="FuzzyLogic_set_MembershipDegree"
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet.FLSfuzziness!==null){
						ret="FuzzyLogic_set_Fuzziness"
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet. FLSfuzzyEntropy!==null){
						ret="FuzzyLogic_set_FuzzyEntropy"
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet. FLSroughness!==null){
						ret="FuzzyLogic_set_Roughness"
					}
				}
			}
			else if(element.uncer2.fuzzySet!==null){
				if(element.uncer2.fuzzySet.FSmembershipDegree!==null){
					if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeValue!==null){
						ret="FuzzySet_MembershipDegree_value"
					}
					else if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeHedge!==null){
						ret="FuzzySet_MembershipDegree_hedge"
					}
					else if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeElement!==null){
						ret="FuzzySet_MembershipDegree_element"
					}
				}
				else if(element.uncer2.fuzzySet.FSfuzziness!==null){
					ret="FuzzySet_Fuzziness"
				}
				else if(element.uncer2.fuzzySet.FSfuzzyEntropy!==null){
					ret="FuzzySet_FuzzyEntropy"
				}
				else if(element.uncer2.fuzzySet.FSroughness!==null){
					ret="FuzzySet_Roughness"
				}
			}
			else if(element.uncer2.intervalValuedFuzzySet!==null){
				if(element.uncer2.intervalValuedFuzzySet.IVFmembershipDegree!==null){
					ret="IntervalValuedFuzzySet_MembershipDegree"
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFfuzziness!==null){
					ret="IntervalValuedFuzzySet_Fuzziness"
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFfuzzyEntropy!==null){
					ret="IntervalValuedFuzzySet_FuzzyEntropy"
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFroughness!==null){
					ret="IntervalValuedFuzzySet_Roughness"
				}
			}
			else if(element.uncer2.LFuzzySet!==null){
				if(element.uncer2.LFuzzySet.LFSmembershipDegree!==null){
					ret="LFuzzySet_MembershipDegree"
				}
				else if(element.uncer2.LFuzzySet.LFSfuzziness!==null){
					ret="LFuzzySet_Fuzziness"
				}
				else if(element.uncer2.LFuzzySet.LFSfuzzyEntropy!==null){
					ret="LFuzzySet_FuzzyEntropy"
				}
				else if(element.uncer2.LFuzzySet.LFSroughness!==null){
					ret="LFuzzySet_Roughness"
				}
			}
			else if(element.uncer2.intuitionisticFuzzySet!==null){
				if(element.uncer2.intuitionisticFuzzySet.IFmembershipDegree!==null){
					ret="IntuitionisticFuzzySet_MembershipDegree"
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFfuzziness!==null){
					ret="IntuitionisticFuzzySet_Fuzziness"
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFfuzzyEntropy!==null){
					ret="IntuitionisticFuzzySet_FuzzyEntropy"
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFroughness!==null){
					ret="IntuitionisticFuzzySet_Roughness"
				}
			}
			else if(element.uncer2.vagueSet!==null){
				if(element.uncer2.vagueSet.VSmembershipDegree!==null){
					ret="VagueSet_MembershipDegree"
				}
				else if(element.uncer2.vagueSet.VSfuzziness!==null){
					ret="VagueSet_Fuzziness"
				}
				else if(element.uncer2.vagueSet.VSfuzzyEntropy!==null){
					ret="VagueSet_FuzzyEntropy"
				}
				else if(element.uncer2.vagueSet.VSroughness!==null){
					ret="VagueSet_Roughness"
				}
			}
			else if(element.uncer2.triangularFuzzyNumber!==null){
				if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberisSha!==null){
					ret="TriangularFuzzyNumber_isSharped"
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumbera!==null){
					ret="TriangularFuzzyNumber_a"
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberb!==null){
					ret="TriangularFuzzyNumber_b"
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberc!==null){
					ret="TriangularFuzzyNumber_c"
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumber!==null){
					ret="TriangularFuzzyNumber_number"
				}

			}
		}
		else if(element.uncer3!==null){
			if(element.uncer3.pignisticDistribution!==null){
				ret="PignisticDistribution_expression";
			}
			else if(element.uncer3.shannonEntropy!==null){
					ret="ShannonEntropy_h";		
			}
			else if(element.uncer3.hartleyMeasure!==null){
					ret="HartleyMeasure_h";		
			}
			else if(element.uncer3.alternativeMeasure!==null){
					ret="AlternativeMeasure_h";		
			}
			else if(element.uncer3.u_Uncertainty!==null){
					ret="U_Uncertainty_h";		
			}
			else if(element.uncer3.dissonanceMeasure!==null){
				if(element.uncer3.dissonanceMeasure.dissonanceMeasureE!==null){
					ret="DissonanceMeasure_e";
				}
				else if(element.uncer3.dissonanceMeasure.dissonanceMeasureComplem!==null){
					ret="DissonanceMeasure_complementray";
				}
				else if(element.uncer3.dissonanceMeasure.conflict!==null){
					ret="DissonanceMeasure_Conflict";
				}		
			}
			else if(element.uncer3.distribution!==null){
				ret="Distribution_expression";
			}
			else if(element.uncer3.beliefInterval!==null){
				if(element.uncer3.beliefInterval.min!==null){
					ret="BeliefInterval_min";
				}
				else if(element.uncer3.beliefInterval.max!==null){
					ret="BeliefInterval_max";
				}
			}
			else if(element.uncer3.possibleDistribution!==null){
			ret="PossibleDistribution_expression";
		    }
		}
		
		
		return ret;
	}
	
	/*«IF param.check.em!==null»
	«distributionFunction(param.check.em.elements)»
	«ENDIF»
	«IF param.^while!==null && param.^while.em!==null»
	«distributionFunction(param.^while.em.elements)»
	«ENDIF»
	«IF param.when!==null && param.when.em!==null»
	«distributionFunction(param.when.em.elements)»
	«ENDIF» */
	def CharSequence create_uncer_h(Signal signal)'''
	#ifndef «signal.name.toUpperCase»_UNCER_H
	#define «signal.name.toUpperCase»_UNCER_H
	#include <stdio.h>
	#include <stdlib.h>
	#include <math.h>
	#include <string.h>
	«FOR name:uncerNames»
	double calc«name»(double var[]);
	«ENDFOR»
	#endif
	'''
	
	def CharSequence create_uncer_c(Signal signal)'''
	#include "«signal.name»_Uncer.h"
	«FOR name:uncerNames»
	double calc«name»(double var[])«distributionFunction(name)»
	
	
	«ENDFOR»
	'''
	
	
	def findSignalsMaxMinValues(Signal s){
		
		for(Oracle o: s.oracle){
			if(o.check.em!==null){
				var List<Double> listadoCombinaciones;
				if(s.superTypeInfer!==null){
					listadoCombinaciones=calcCombinations(o, s.superType.monitoringPlan, s.superTypeInfer.monitoringInferVariables);
				
				}
				else{
					listadoCombinaciones=calcCombinations2(o,s.superType.monitoringPlan);
				}
				maxMap.put(o.name,Collections.max(listadoCombinaciones));
				minMap.put(o.name,Collections.min(listadoCombinaciones));
			}
			else{
				var max=0.0;
				var min=0.0;
				for(MonitoringPlan a:s.superType.monitoringPlan){
					if(a.monitoringVariables.name.equals(o.check.name)){
						if(a.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
							max=1.0;
							min=0.0;
						}
						else{
							max=a.monitoringVariables.max.DVal;
							min=a.monitoringVariables.min.DVal;
						}
					}
				}
				maxMap.put(o.name,max);
				minMap.put(o.name,min);
			}
		}
	}
	
	def calcCombinations2(Oracle oracle, EList<MonitoringPlan> list) {
		var String expresionWithVars=getExpressionWithVars(oracle.check.em.elements);
		var List<String> varNames = diffVarNames(oracle);
		var List<String> exprCombs = new ArrayList<String>();
		var List<Double> maxMinValueCombs = new ArrayList();
		var List<Double> minValues= getMinValues2(varNames,list);
		var List<Double> maxValues= getMaxValues2(varNames,list);
		exprCombs = generateCombinations(0, expresionWithVars, varNames, exprCombs, minValues,maxValues);
		for(String expression:exprCombs){
			maxMinValueCombs.add(evalExpression(expression));
		}
	//TODO set values
		if(maxMinValueCombs.size()==0){
			maxMinValueCombs.add(0.0);
		}
		return maxMinValueCombs;
	}
	
	def getMaxValues2(List<String> strings, EList<MonitoringPlan> list) {
		var List<Double> maxValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						maxValues.add(1.0);
					}
					else{
						maxValues.add(plan.monitoringVariables.max.DVal);
					}
				}
			}	
		}
		return maxValues;
	}
	
	def getMinValues2(List<String> strings, EList<MonitoringPlan> list) {
		var List<Double> minValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						minValues.add(0.0);
					}
					else{
						minValues.add(plan.monitoringVariables.min.DVal);
					}
				}
			}
		}
		return minValues;
	}
	
	def calcCombinations(Oracle oracle, EList<MonitoringPlan> list,EList<MonitoringInferVariables> listInfer) {
		var String expresionWithVars=getExpressionWithVars(oracle.check.em.elements);
		var List<String> varNames = diffVarNames(oracle);
		var List<String> exprCombs = new ArrayList<String>();
		var List<Double> maxMinValueCombs = new ArrayList();
		var List<Double> minValues= getMinValues(varNames,list,listInfer);
		var List<Double> maxValues= getMaxValues(varNames,list,listInfer);
		exprCombs = generateCombinations(0, expresionWithVars, varNames, exprCombs, minValues,maxValues);
		for(String expression:exprCombs){
			maxMinValueCombs.add(evalExpression(expression));
		}
	//TODO set values
		if(maxMinValueCombs.size()==0){
			maxMinValueCombs.add(0.0);
		}
		return maxMinValueCombs;
	}
	def evalExpression(String expression) {
		var engine = new GraalJSEngineFactory().getScriptEngine();
		try {
			var obj = String.valueOf(engine.eval(expression));
			var ret= Double.valueOf(obj);
			return ret;
		} catch (ScriptException e) {
			e.printStackTrace();
			return null;
		}
	}
	def getMinValues(List<String> strings, EList<MonitoringPlan> list ,EList<MonitoringInferVariables> listInfer) {
		var List<Double> minValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						minValues.add(0.0);
					}
					else{
						minValues.add(plan.monitoringVariables.min.DVal);
					}
				}
			}
			if(listInfer!==null){
				for(MonitoringInferVariables variable: listInfer){
					if(variable.name.equals(name)){
						if(variable.monitoringVariableDatatype.sig_type.equals("boolean")){
							minValues.add(0.0);
						}
						else{
							minValues.add(variable.min.DVal);
						}
					}
				}
			}
		}
		return minValues;
	}
	
	def getMaxValues(List<String> strings, EList<MonitoringPlan> list,EList<MonitoringInferVariables> listInfer) {
		var List<Double> maxValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						maxValues.add(1.0);
					}
					else{
						maxValues.add(plan.monitoringVariables.max.DVal);
					}
				}
			}if(listInfer!==null){
				for(MonitoringInferVariables variable: listInfer){
					if(variable.name.equals(name)){
						if(variable.monitoringVariableDatatype.sig_type.equals("boolean")){
							maxValues.add(0.0);
						}
						else{
							maxValues.add(variable.max.DVal);
						}
					}
				}
			}
		}
		return maxValues;
	}
	
	def List<String> generateCombinations(int index, String expression, List<String> varNames, List<String> exprCombs, List<Double> maxValues,List<Double> minValues) {
		var List<String> exC = new ArrayList<String>(exprCombs)
		if(!expression.equals("")){
			var String replaceVarMin = replaceVar(expression, varNames.get(index),minValues.get(index));
			var String replaceVarMax = replaceVar(expression, varNames.get(index),maxValues.get(index));
			if (index == varNames.size() - 1) {
				exC.add(replaceVarMin);
				exC.add(replaceVarMax);
			} else {
				var List<String> minCombs = generateCombinations(index + 1, replaceVarMin, varNames, exprCombs,maxValues,minValues);
				var List<String> maxCombs = generateCombinations(index + 1, replaceVarMax, varNames, exprCombs,maxValues,minValues);
				exC.addAll(minCombs);
				exC.addAll(maxCombs);
			}
		}
		return exC;
	}
	
	def replaceVar(String expression, String varName, Double value) {
		var String values="";
		if(value<0){
			values="("+Double.toString(value)+")";
		}
		else{
			values=Double.toString(value);
		}
		return expression.replace("@@" + varName + "@@", values);
	}
	
	def diffVarNames(Oracle oracle) {
		var List<String> varNames = new ArrayList<String>();
		for(AbstractElement2 name: oracle.check.em.elements)
		if(name.name!==null){
			varNames.add(name.name);
		}
		return varNames;
	}
	
	def getExpressionWithVars(EList<AbstractElement2> elements) {
		var String expression = "";
		for (AbstractElement2 element : elements) {
			if (element.getFrontParentheses().size() > 0) {
				for(var i=0; i<element.getFrontParentheses().size(); i++){
					expression += "(";
				}
				
			}
			if (element.getName() !== null) {
				expression += "@@" + element.getName() + "@@";
			}
			if (element.getValue() !== null) {
				if(element.getValue().getDVal()<0){
					expression += String.valueOf(element.getValue().getDVal());
				}
				else{
					expression += String.valueOf(element.getValue().getDVal());
				}
				
			}
			if (element.getOp() !== null) {
				for (Operators op : element.getOp()) {
					if (op.getOperator() !== null) {
						expression += op.getOperator().getOp().toString();
					} else if (op.getComparation() !== null) {
						expression += op.getComparation().getOp().toString();
					} else if (op.getLogicOperator() !== null) {
						expression += op.getLogicOperator().getOp().toString();
					} else if (op.getBackParentheses() !== null) {
						expression += op.getBackParentheses();
					}
				}
			}
		}
		return expression;
	}
	
	def appendFile(Signal s,String dotC, String dotVerdict) {
		var List<String> lineak= new ArrayList();
		var File myObj;
		var Scanner myReader;
		var String data;
		try {
	      myObj = new File(directory+dotC);
	      //println("Working Directory = " + System.getProperty("user.dir"));
	      myReader = new Scanner(myObj);
	      while (myReader.hasNextLine()) {
	        data = myReader.nextLine();
	        lineak.add(data);
	      }
	      myReader.close();
	    } catch (FileNotFoundException e) {
	      System.out.println("An error occurred.");
	      e.printStackTrace();
	    }
	    try {
	      myObj = new File(directory+dotVerdict);
	      myReader = new Scanner(myObj);
	      while (myReader.hasNextLine()) {
	        data = myReader.nextLine();
	        lineak.add(data);
	      }
	      myReader.close();
	    } catch (FileNotFoundException e) {
	      System.out.println("An error occurred.");
	      e.printStackTrace();
	    }
	    var FileWriter writer = new FileWriter(directory+dotC); 
		for(String str: lineak) {
		  writer.write(str + System.lineSeparator());
		}
		writer.close();
		
		
	}
	
	def CharSequence create_array_c(Signal s)'''
	#include "Array.h"
	void initArray(Array *a, size_t initialSize) {
		if (a->size == a->used) {
			a->array = malloc(initialSize * sizeof(double));
			a->used = 0;
			a->size = initialSize;
		}
	}
	
	void insertArray(Array *a, double element) {
		a->array[a->used++] = element;
		if (a->used == a->size) {
			a->size *= 2;
			a->array = realloc(a->array, a->size * sizeof(double));
		}
	
	}
	
	void freeArray(Array *a) {
		free(a->array);
		a->array = NULL;
		a->used = a->size = 0;
	}
	
	'''
	def create_global_h(Signal s)'''
	#ifndef «s.fullyQualifiedName.toUpperCase.toString»_H
	#define «s.fullyQualifiedName.toUpperCase.toString»_H
	#include <stdio.h>
	#include "Array.h"
	
	enum VerdictValue{
		VERDICT_PASSED,
		VERDICT_FAILED,
		VERDICT_INCONCLUSIVE,
		VERDICT_NONE,
		VERDICT_ERROR
	};
	enum VerdictType{
		VERDICTTYPE_CYCLE,
		VERDICTTYPE_PARTIAL,
		VERDICTTYPE_GLOBAL
	};
	typedef struct Verdict{
		enum VerdictValue verdict;
		double confidence;
		enum VerdictType type;
	}Verdict;
	typedef struct{
	«FOR plan: s.superType.monitoringPlan»
		«"\t"»double «plan.monitoringVariables.name»;
	«ENDFOR»	
	«"\t"»double timeStamp;
	}SensorInput, *SENSOR_INPUT;
	
	#endif
	
	'''
	def CharSequence create_array_h(Signal s)'''
	#ifndef ARRAY_H
	#define ARRAY_H
	#include <stdio.h>
	typedef struct {
		double *array;
		size_t used;
		size_t size;
	} Array;
	void initArray(Array *a, size_t initialSize);
	void insertArray(Array *a, double element);
	void freeArray(Array *a);
	
	#endif
	'''
	
//	def create_VP_json(ValidationPlan plan)'''
//	{
//	«"\t"»"tests" : {
//	«FOR test: plan.test»
//	«"\t\t"»"«test.name»" : {
//	«"\t\t\t"»"SUT": "«test.sut»" ,
//	«"\t\t\t"»"TestLevel": "«test.testLevel»" ,
//	«"\t\t\t"»"inputs": «FOR input : test.inputs» "«input.value»", «ENDFOR»
//	«"\t\t\t"»"oracles": {«FOR oracle: test.oracles»
//	«"\t\t\t\t"»"«oracle.name»" :{
//	«"\t\t\t\t\t"»"type": "«oracle.type»",
//	«"\t\t\t\t\t"»"prams": «FOR param: oracle.parameters»"«FOR param1: param.value.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»,"«ENDFOR»
//	«"\t\t\t\t"»},
//	«ENDFOR»
//	«"\t\t\t"»},
//	«"\t\t"»},
//	«ENDFOR»
//	«"\t"»}
//	}
//	'''
	
	def getAllNames(Signal signal) {
		var List<String> namelists;
		var List<String> whileNames;
		var List<String> whenNames;
		var List<String> checkNames;
		
		var Oracle oracle;
		var boolean is;
		for(var z=0; z< signal.oracle.size; z++){
			oracle=signal.oracle.get(z);
			namelists=new ArrayList();
			checkNames=new ArrayList();
			is=false;
			if(oracle.check.em!==null){
				for(var i=0; i< oracle.check.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(oracle.check.em.elements.get(i).name===null ||(namelists.get(j)!==null && namelists.get(j).equals(oracle.check.em.elements.get(i).name)) || oracle.check.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is && oracle.check.em.elements.get(i).name!==null){
						namelists.add(oracle.check.em.elements.get(i).name);
					}
					else{
						is=false;
					}
				}
			}
			else{
				namelists.add(oracle.check.name);
			}
			
			is=false;
			if(oracle.^while!==null){
				whileNames= new ArrayList();
				var wile=oracle.^while;
				var isWHile=false;
				for (var i=0; i<wile.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(wile.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(wile.em.elements.get(i).name);
						
					}
					else{
						is=false;
					}
					for(var j=0; j<whileNames.size;j++){
						if(wile.em.elements.get(i).name===null || (whileNames.get(j)!==null && whileNames.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							isWHile=true;
						}
					}
					if(!isWHile){
						whileNames.add(wile.em.elements.get(i).name);
						
					}
					else{
						isWHile=false;
					}
				}
				whileNames=addUncerNames(wile.em, whileNames);
				var a="";
				var b="";
				for(var i=0; i< whileNames.size; i++){
					if(i!=whileNames.size-1){
						a=a+"double "+whileNames.get(i)+", ";
						b=b+whileNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"double "+whileNames.get(i);
						b=b+whileNames.get(i)+".array[cycle] ";
					}
				}
				whileMap.put(oracle.name,a);
				whileMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.when!==null){
				whenNames= new ArrayList();
				var isWhen= false;
				var when=oracle.when;
				for (var i=0; i<when.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(when.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(when.em.elements.get(i).name);
					}
					else{
						is=false;
					}
					for(var j=0; j<whenNames.size;j++){
						if(when.em.elements.get(i).name===null || (whenNames.get(j)!==null && whenNames.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							isWhen=true;
						}
					}
					if(!isWhen){
						whenNames.add(when.em.elements.get(i).name);
					}
					else{
						isWhen=false;
					}
				}
				whenNames=addUncerNames(when.em, whenNames);
				var a="";
				var b="";
				for(var i=0; i< whenNames.size; i++){
					if(i!=whenNames.size-1){
						a=a+"double "+whenNames.get(i)+", ";
						b=b+whenNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"double "+whenNames.get(i);
						b=b+whenNames.get(i)+".array[cycle]";
					}
				}
				whenMap.put(oracle.name,a);
				whenMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.check.reference!==null){
				if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
			
				else if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.upper!==null && oracle.check.reference.upper.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.upper.bound_upp.em.elements.size; i++){
						
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.same!==null && oracle.check.reference.same.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.same.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
							checkNames.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.notsame!==null && oracle.check.reference.notsame.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.notsame.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference!==null){
					if(oracle.check.reference.lower!==null && oracle.check.reference.lower.bound_lower.em!==null){
						for(var i=0; i<oracle.check.reference.lower.bound_lower.em.elements.size; i++){
							for(var j=0; j<namelists.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							namelists.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
							is=false;
							for(var j=0; j<checkNames.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							checkNames.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
						}
					}
				}
				
			}
			var namelists2= new ArrayList();
			for(var i=0; i<checkNames.size; i++){
				if(checkNames.get(i)!==null){
					namelists2.add(checkNames.get(i));
				}
			}	
			namelists=getDistributionNames(oracle,namelists);	
			nameMap.put(oracle.name, namelists);
			checkVar.put(oracle.name,namelists2);
		}
	}
	

	def List<String> addUncerNames(ExpressionsModel model, List<String> names) {
		var boolean is=false;
		var String name="";
		for(AbstractElement2 element: model.elements){
			if(element.uncer1!==null){
				name=getUncerName(element.uncer1);
				for(String isName: names){
					if(isName!==null && isName.equals(name)){
						is=true;
					}
				}
				if(!is){
					names.add(name);
				}
				is=false;
			}
			else if(element.uncer2!==null){
				name=getUncerName2(element.uncer2);
				for(String isName: names){
					if(isName!==null && isName.equals(name)){
						is=true;
					}
				}
				if(!is){
					names.add(name);
				}
				is=false;
			}
			else if(element.uncer3!==null){
				name=getUncerName3(element.uncer3);
				for(String isName: names){
					if(isName!==null && isName.equals(name)){
						is=true;
					}
				}
				if(!is){
					names.add(name);
				}
				is=false;
			}
		}
		names.remove(null);
		return names;
	}
	
	def String getUncerName2(UncertaintyVagueness vagueness) {
		var String name="";
		if(vagueness.fuzzyInterval!==null){
			name=vagueness.fuzzyInterval.name;
		}
		else if(vagueness.fuzzySetCut!==null){
			name=vagueness.fuzzySetCut.name;
		}
		
		else if(vagueness.fuzzyLogic!==null){
			name=vagueness.fuzzyLogic.name;
		}
		
		else if(vagueness.fuzzySet!==null){
			name=vagueness.fuzzySet.name;
		}
		
		else if(vagueness.intervalValuedFuzzySet!==null){
			name=vagueness.intervalValuedFuzzySet.name;
		}
		
		else if(vagueness.LFuzzySet!==null){
			name=vagueness.LFuzzySet.name;
		}
		
		else if(vagueness.intuitionisticFuzzySet!==null){
			name=vagueness.intuitionisticFuzzySet.name;
		}
		
		else if(vagueness.vagueSet!==null){
			name=vagueness.vagueSet.name;
		}
		
		else if(vagueness.triangularFuzzyNumber!==null){
			name=vagueness.triangularFuzzyNumber.name;
		}
		
		else if(vagueness.roughSet!==null){
			name=vagueness.roughSet.name;
		}
		
		else if(vagueness.sharpness!==null){
			name=vagueness.sharpness.name;
		}
		
		else if(vagueness.sharpness!==null){
			name=vagueness.sharpness.name;
		}
		return name;
	}
	
	def String getUncerName3(UncertaintyAmbiguity ambiguity) {
		var String name="";
		if(ambiguity.pignisticDistribution!==null){
			name=ambiguity.pignisticDistribution.name;
		}
				
		else if(ambiguity.shannonEntropy!==null){
			name=ambiguity.shannonEntropy.name;
		}
		
		else if(ambiguity.hartleyMeasure!==null){
			name=ambiguity.hartleyMeasure.name;
		}
		
		else if(ambiguity.alternativeMeasure!==null){
			name=ambiguity.alternativeMeasure.name;
		}
		
		else if(ambiguity.u_Uncertainty!==null){
			name=ambiguity.u_Uncertainty.name;
		}
		
		else if(ambiguity.dissonanceMeasure!==null){
			name=ambiguity.dissonanceMeasure.name;
		}
		
		else if(ambiguity.distribution!==null){
			name=ambiguity.distribution.name;
		}
		
		else if(ambiguity.beliefInterval!==null){
			name=ambiguity.beliefInterval.name;
		}
		
		else if(ambiguity.possibleDistribution!==null){
			name=ambiguity.possibleDistribution.name;
		}
		
		else if(ambiguity.possibleDistribution!==null){
			name=ambiguity.possibleDistribution.name;
		}
		return name;
	}
	
	def List<String> getDistributionNames(Oracle o,List<String> strings) {
		var boolean is=false;
		var String name="";
		if(o.when!==null && o.when.em!==null){
			for(var i=0; i<o.when.em.elements.size; i++){
				if(o.when.em.elements.get(i).uncer1!==null){
					name=getUncerName(o.when.em.elements.get(i).uncer1)
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.when.em.elements.get(i).uncer2!==null){
					name=getUncerName2(o.when.em.elements.get(i).uncer2)
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.when.em.elements.get(i).uncer3!==null){
					name=getUncerName3(o.when.em.elements.get(i).uncer3)
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
			}
		}
		if(o.^while!==null && o.^while.em!==null){
			for(var i=0; i<o.^while.em.elements.size; i++){
				if(o.^while.em.elements.get(i).uncer1!==null){
					name=getUncerName(o.^while.em.elements.get(i).uncer1);
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.^while.em.elements.get(i).uncer2!==null){
					name=getUncerName2(o.^while.em.elements.get(i).uncer2);
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.^while.em.elements.get(i).uncer3!==null){
					name=getUncerName3(o.^while.em.elements.get(i).uncer3);
					for(String isName:strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
			}
			
		}
		if(o.check!==null && o.check.em!==null){
			for(var i=0; i<o.check.em.elements.size; i++){
				if(o.check.em.elements.get(i).uncer1!==null){
					name=getUncerName(o.check.em.elements.get(i).uncer1)
					for(String isName: strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.check.em.elements.get(i).uncer2!==null){
					name=getUncerName2(o.check.em.elements.get(i).uncer2)
					for(String isName: strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
				else if(o.check.em.elements.get(i).uncer3!==null){
					name=getUncerName3(o.check.em.elements.get(i).uncer3)
					for(String isName: strings){
						if(isName!==null && isName.equals(name)){
							is=true;
						}
					}
					if(!is){
						strings.add(name);
					}
					is=false;
				}
			}
		}
		return strings
	}
	
	def String getUncerName(UncertaintyProb prob) {
		var String ret="";
		if(prob.bernoulliDistribution!==null){
			ret=prob.bernoulliDistribution.name;
		}
		
		else if(prob.gammaDistribution!==null){
			ret=prob.gammaDistribution.name;
		}
		
		else if(prob.normalDisstribution!==null){
			ret=prob.normalDisstribution.name;
		}
		
		else if(prob.uniformDistribution!==null){
			ret=prob.uniformDistribution.name;
		}
		
		else if(prob.percentage!==null){
			ret=prob.percentage.name;
		}
		
		
		return ret;
	}
		
	def CharSequence create_oracle_json(Signal CPS)	'''
	{ 
		"«CPS.name»": {
			"inputVariationPoints": [
				«FOR param1:CPS.superType.monitoringPlan»
				{
					"name":"«param1.monitoringVariables.name»",
					"datatype": "«param1.monitoringVariables.monitoringVariableDatatype.sig_type»",
					"used by" : [
						«getOracles(param1.monitoringVariables.name)»
					]
				}«IF CPS.superType.monitoringPlan.indexOf(param1)!==CPS.superType.monitoringPlan.size-1»,«ENDIF»
				«ENDFOR»
			],
			«IF CPS.superTypeInfer!==null»
			«IF CPS.superTypeInfer.monitoringInferVariables.size!==0»
			"sinteticVariationPoints": [
				«FOR SV: CPS.superTypeInfer.monitoringInferVariables»
				{
					"name":"«SV.name»",
					"datatype":"«SV.monitoringVariableDatatype.sig_type»",
					"model":"«SV.model»"
				}«IF CPS.superTypeInfer.monitoringInferVariables.indexOf(SV)!==CPS.superTypeInfer.monitoringInferVariables.size-1»,«ENDIF»
				«ENDFOR»
			],
			«ENDIF»
			«IF CPS.superTypeInfer.superType.trainableModel!==null»
			«IF CPS.superTypeInfer.superType.trainableModel.size!==0»
			"trainableModels": [
				«FOR TM: CPS.superTypeInfer.superType.trainableModel»
				{
					"name":"«TM.name»"
				}«IF CPS.superTypeInfer.superType.trainableModel.indexOf(TM)!==CPS.superTypeInfer.superType.trainableModel.size-1»,«ENDIF»
				«ENDFOR»
			],
			«ENDIF»
			«ENDIF»
			«IF CPS.superTypeInfer.superType.nonTrainableModel!==null»
			«IF CPS.superTypeInfer.superType.nonTrainableModel.size!==0»
			"nonTrainableModel": [
				«FOR NTM: CPS.superTypeInfer.superType.nonTrainableModel»
				{
					"name":"«NTM.name»",
					"URL":"«NTM.model»"
				}«IF CPS.superTypeInfer.superType.nonTrainableModel.indexOf(NTM)!==CPS.superTypeInfer.superType.nonTrainableModel.size-1»,«ENDIF»
				«ENDFOR»
			],
			«ENDIF»
			«ENDIF»
			«ENDIF»
			"evaluationFunctions": [
				«getOracleNames(CPS.oracle)»
			]
		}
	}
	'''
	
	def String getOracles(String name) {
		var String ret="";
		var Set<String> list=varAndOracles.get(name);
		
		if(list!==null){
			for(var i=0; i< list.size; i++){
				if(i<list.size-1){
					ret=ret+"\""+list.get(i)+"\",\n";
				}	
				else{
					ret=ret+"\""+list.get(i)+"\"\n";
				}			
			}
		}
		
		return ret;
	}
	
	def String getOracleNames(EList<Oracle> list) {
		var String ret="";
		for(var i=0; i<list.size; i++){
			ret=ret+"{\n\t\"name\": \""+list.get(i).name+"\"\n";
			if(i==list.size-1){
				ret=ret+"}\n";
			}
			else{
				ret=ret+"},\n";
			}
		}
		return ret;
	}
	
	

	//TODO division .h global(añadir verdict formato que esta en array.h) y .h por oraculo
	def create_oracle_h(Oracle param, List<String> nameList, String name)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	
	#include "oracle_commons.h"
	#include "«name»_Uncer.h"
	
	int preprocessInputs_«param.name»(SensorInput *inputs);
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs);
	Verdict performEvaluation_«param.name»(SensorInput *inputs);
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle);
	«IF param.check.reference.upper!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.lower!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.same!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.notsame!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.range!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR» double signal);
	«ELSEIF param.check.reference.gap!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ENDIF»
	#endif
	'''
	def create_C_oracle_h(CustomOracle param, String name)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	
	#include "oracle_commons.h"
	int preprocessInputs_«param.name»(SensorInput *inputs);
	«IF param.precondition!==null»
	int evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1» double «inputName», «ELSE»double «inputName» «ENDIF»«ENDFOR»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs);
	Verdict performEvaluation_«param.name»(SensorInput *inputs);
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle);
	double confCalculator_«param.name»(«FOR param1:param.checkInputs»double «param1.toString»,«ENDFOR»double signal);
	'''
	
	
	
	
	def create_verdict_c(Oracle param, List<String> nameList){
		verdict.add("Verdict checkGlobalVerdict_"+param.name+"(Array conf, Array timeStampOracle){");
		verdict.add("	Verdict verdict={VERDICT_INCONCLUSIVE, 0.0, VERDICTTYPE_GLOBAL};");
		verdict.add("	double times;");
		verdict.add("	int fail, is, deg,i,time;");
		verdict.add("	i=0;");
		verdict.add("	while (i < conf.used && verdict.verdict==2) {");
		verdict.add("		if (conf.array[i] != 2) {");
		verdict.add("			verdict.verdict = VERDICT_PASSED;");
		verdict.add("		}");
		verdict.add("		i++;");
		verdict.add("	}");
		verdict.add("	if (verdict.verdict == 2) {");
		verdict.add("		return verdict;");
		verdict.add("	}");
		for(FailReason param1: param.check.failReason){
			if(param1.reason.highTime!==null){
				verdict.add("	fail =0;");
				verdict.add("	time=0;");
				verdict.add("	is=0;");
				verdict.add("	i=0;");
				verdict.add("	while(fail==0 && i<conf.used){");
				verdict.add("		if(conf.array[i]<"+param1.reason.highTime.cant.DVal+"){");
				verdict.add("			is==1;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("		time=i;");
				verdict.add("		while (is==1 && i<conf.used){");
				verdict.add("			if(conf.array[i]<"+param1.reason.highTime.cant.DVal+" && timeStampOracle.array[i] - timeStampOracle.array[time]>"+param1.reason.highTime.time.DVal+" || timeStampOracle.array[i] - timeStampOracle.array[time]>"+param1.reason.highTime.time.DVal+"){");
				verdict.add("				fail=1;");
				verdict.add("			}");
				verdict.add("			else{");
				verdict.add("				is=0;");
				verdict.add("			}");
				verdict.add("			i++;");
				verdict.add("		}");
				verdict.add("	}");
				verdict.add("	if(fail==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
								
			}	
			else if(param1.reason.highPeak!==null){
				verdict.add("	i=0;");
				verdict.add("	for(i=0; i< conf.used; i++){");
				verdict.add("		if(conf.array[i]<"+param1.reason.highPeak.cant.DVal+"){");
				verdict.add("			verdict.verdict=VERDICT_FAILED;");
				verdict.add("		}");
				verdict.add("	}");
			}
			else if(param1.reason.constDeg!==null){
				verdict.add("	deg=0;");
				verdict.add("	i=0;");
				verdict.add("	while(deg==0 && i<conf.length){");
				verdict.add("		if(conf.array[i]<"+param1.reason.constDeg.cant.DVal+"){");
				verdict.add("			deg=1;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	while(deg==1 && i<conf.used){");
				verdict.add("		if(conf.array[i]>"+param1.reason.constDeg.cant.DVal+"){");
				verdict.add("			deg=0;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	if(i==conf.used && deg==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
	
				
			}
			else if(param1.reason.XPeaks!==null){
				verdict.add("	i=0;");
				verdict.add("	times="+param1.reason.XPeaks.NPeaks.DVal+";");
				verdict.add("	time=0;");
				verdict.add("	fail=0;");
				verdict.add("	while(i<conf.used && fail==0){")
				verdict.add("		if(conf.array[i]<"+param1.reason.XPeaks.cant.DVal+"){");
				verdict.add("			if(time==0){");
				verdict.add("				time=i;");
				verdict.add("			}");
				verdict.add("			times--;");
				verdict.add("			if(times==0 && timeStampOracle.array[i] - timeStampOracle.array[time]<"+param1.reason.XPeaks.time.DVal+"){");
				verdict.add("				fail=1;	");
				verdict.add("			}");
				verdict.add("			else if(times==0){");
				verdict.add("				times=0;");
				verdict.add("			}");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	if(fail==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
			}	
		}
		verdict.add("	return verdict;");
		verdict.add("}");
	}
	//TODO: add claclUncertainty.
	def create_oracle_c(Oracle param,List<String> nameList)
	'''
	#include "«param.name.toString()».h"
			
	«IF param.check.description!==null»/*«param.check.description.value»*/«ENDIF»
	
	int preprocessInputs_«param.name»(SensorInput *inputs) {
		//TODO.
	    return 1;
	}
	«IF param.when!==null || param.^while!==null»

	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF») {
		return «IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal<0»(«param1.value.DVal»)«ELSE»«param1.value.DVal»«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«param1.value.DVal»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»;
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs){
	    Verdict verdict;
		//Step 1: inicializacion
	    static int cycle = -1;
		static Array timeStampOracle; 
	«FOR param1: nameMap.get(param.name)»
		static Array «param1»;
	«ENDFOR»
		static Array conf;
		static Array preconditionGiven;
	
		//Init arrays
		initArray(&conf,1);
		initArray(&preconditionGiven,1);
		initArray(&timeStampOracle,1);
	«FOR param1: nameMap.get(param.name)»
		initArray(&«param1» ,1);
	«ENDFOR»
		//Step 2: meter variables en array
		cycle++;
		insertArray(&timeStampOracle,inputs->timeStamp);
	«FOR param1: nameMap.get(param.name)»
	«"\t"»insertArray(&«param1»,inputs->«param1»);
	«ENDFOR»
	«IF param.when!==null || param.^while!==null»
	«"\t"»insertArray(&preconditionGiven,evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap_preconds.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap_preconds.get(param.name).toString»«ENDIF»));	
	«"\t"»if(preconditionGiven.array[cycle]==1){
		//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
	«"\t"»	insertArray(&conf,confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
	«"\t"»}else{
	«"\t"»	insertArray(&conf,2);
	«"\t"»}
		«ELSE»
	«"\t"»insertArray(&preconditionGiven,2);
	«"\t"»insertArray(&conf,confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
		«ENDIF»

		//Step 4: Sacar confidence

		verdict = checkGlobalVerdict_«param.name»(conf, timeStampOracle); 
		verdict.confidence=conf.array[cycle];
		
	    return verdict;
	}		
	
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal){
		double conf=0;
		«confCalculationBody»
		«IF param.check.reference.gap!==null»
		if(signal<«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal>«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal<«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
		}
		else if(signal>«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSEIF param1.math!==null»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ELSE»«DistributionManagement(param1)»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);

		}
		«ENDIF»
		return conf;
	}
	«FOR String a:verdict»
	«a»
	«ENDFOR»
	
	'''
	def create_C_oracle_c(CustomOracle param)'''
	#include "«param.name.toString()».h"
				
	«IF param.description!==null»/*«param.description»*/«ENDIF»
	
	int preprocessInputs_«param.name»(SensorInput *inputs) {
			//TODO.
		    return 1;
	}
	«IF param.precondition!==null»
	int evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1» double «inputName», «ELSE»double «inputName» «ENDIF»«ENDFOR»);
		//TODO
		return
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs){
	    Verdict verdict;
		//Step 1: inicializacion
	    static int cycle = -1;
		static Array timeStampOracle;
	«FOR param1: predAndCheckInputs»
	«"\t"»static Array «param1»;
	«ENDFOR»

		static Array conf;
		static Array preconditionGiven;
	
		//Init arrays
		initArray(&conf,1);
		initArray(&preconditionGiven,1);
		initArray(&timeStampOracle,1);
	«FOR param1: predAndCheckInputs»
	«"\t"»initArray(&«param1» ,1);
	«ENDFOR»
		//Step 2: meter variables en array
		cycle++;
		insertArray(&timeStampOracle,inputs->timeStamp);
	«FOR param1: predAndCheckInputs»
	«"\t"»insertArray(&«param1»,inputs->«param1»);
	«ENDFOR»

	«IF param.precondition!==null»
	«"\t"»insertArray(&preconditionGiven,evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1»«inputName», «ELSE»«inputName» «ENDIF»«ENDFOR»);	
	«"\t"»if(preconditionGiven.array[cycle]==1){
	«"\t"»//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
	«"\t\t"»insertArray(&conf,confCalculator_«param.name»(«FOR inputName:param.checkInputs»«IF param.checkInputs.indexOf(inputName)<param.checkInputs.size()-1»«inputName».array[cycle], «ELSE»«inputName».array[cycle] «ENDIF»«ENDFOR»);
	«"\t"»}else{
	«"\t\t"»insertArray(&conf,2);
	«"\t"»}
	«ELSE»
	«"\t"»insertArray(&preconditionGiven,2);
	«"\t"»insertArray(&conf,confCalculator_«param.name»(«FOR inputName:param.checkInputs»«IF param.checkInputs.indexOf(inputName)<param.checkInputs.size()-1»«inputName».array[cycle], «ELSE»«inputName».array[cycle] «ENDIF»«ENDFOR»);
	«ENDIF»
	//Step 4: Sacar confidence
	
		verdict = checkGlobalVerdict_«param.name»(conf, timeStampOracle); 
		verdict.confidence=conf.array[cycle];
		
	    return verdict;
	}
	double confCalculator_«param.name»(«FOR param1:param.checkInputs»double «param1.toString»,«ENDFOR»double signal){
		double conf=0;
		
		//TODO
		
		return conf;
	}
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle){
		verdict.verdict=VERDICT_INCONCLUSIVE;
	}	
	'''

	def String distributionFunction(String name) {
		var String ret="";
		switch(name){
//			case "BernoulliDistribution_prob":{
//				ret="{\n\n}";
//			}
//			case "BernoulliDistribution_trials":{
//				ret="{\n\n}";
//			}
//			case "GammaDistribution_K":{
//				ret="{\n\n}";
//			}
			case "GammaDistribution_mean":{
				ret="{\n\t int length=0;\n\t length=sizeof(var);\n\t int i;\n\t double ave, s=var[0];\n\t for(i=1;i<length;i++){\n\t  s=s+var[i];\n\t  ave=s/(float)length;\n\t }\n\t return ave;\n}";
			}
			case "NormalDistribution_mean":{
				ret="{\n\t int length=0;\n\t length=sizeof(var);\n\t int i;\n\t double ave, s=var[0];\n\t for(i=1;i<length;i++){\n\t  s=s+var[i];\n\t  ave=s/(float)length;\n\t }\n\t return ave;\n}";
			}
			case "NormalDistribution_normDistStd":{
				ret="{\n\t double sum=0.0, mean, SD=0.0;\n\t int length=0;\n\t length=sizeof(var);\n\t int i;\n\t for(i=0; i<length; ++i){\n\t  sum += var[i];\n\t }\n\t mean=sum/length;\n\t for(i=0; i<length; ++i){\n\t  SD += pow(var[i]-mean, 2);\n\t }\n\t return sqrt(SD/length);\n}";
			}
			case "UniformDistribution_Max":{
				ret="{\n\t double max=var[0];\n\t int length=0, i=0;\n\t length=sizeof(var);\n\t for(i=1; i<length; i++){\n\t  if(max<var[i])\n\t   max=var[i];\n\t }\n\t return max;\n}";
			}
			case "UniformDistribution_Min":{
				ret="{\n\t double min=var[0];\n\t int length=0, i=0;\n\t length=sizeof(var);\n\t for(i=1; i<length; i++){\n\t  if(min>var[i])\n\t   min=var[i];\n\t }\n\t return min;\n}";
			}
			//The percentage calculation depends on the specific problem, here implement based on example in D4.1 
			case"Percentage_value":{
				ret="{\n\t double percentage=0.0;\n\t int length=0,i=0, count=0;\n\t length=sizeof(var);\n\t for(i=0; i<length; i++){\n\t  if(var[i]<=30)\n\t  count=count+1;\n\t }\n\t percentage=(double)count/(double)length;\n\t return percentage;\n}";
			}
//			case "FuzzyInterval_maxfuzzyNumber":{
//				ret="{\n\n}";
//			}
//			case "FuzzyInterval_minfuzzyNumber":{
//				ret="{\n\n}";
//			}
//			case "FuzzySetCut_lambda":{
//				ret="{\n\n}";
//			}
//			case "FuzzySetCut_isStrong":{
//				ret="{\n\n}";
//			}
//			case "FuzzySetCut_kind":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_operator":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_var":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_set":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_set.Fuzziness":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_set.FuzzyEntropy":{
//				ret="{\n\n}";
//			}
//			case "FuzzyLogic_set.Roughness":{
//				ret="{\n\n}";
//			}
			
			//The Fuzzy function of different system is different, there is no uniform calculation. It should be customized according to different system. Here give an example based on self-driving car's deviation correction function.  
			//The input should be one parameter, since here is array, it can be var[0]
			case "FuzzySet_MembershipDegree_value":{
				ret="{\n\t double value=0.0;\n\t if(var[0]>=-0.8 && var[0]<=0)\n\t  value=-1.25*var[0];\n\t else if(var[0]>0 && var[0]<=0.8)\n\t  value=1.25*var[0];\n\t else\n\t  value=1;\n\t return value;\n}";
			}
			//The element type is string, so the output should be string, considering the output type of the predefined function is double, here, use -1(represent LEFT) and 1(represent RIGHT) in example.
			case "FuzzySet_MembershipDegree_element":{
				ret="{\n\t double element=0.0;\n\t if(var[0]<0)\n\t  element=-1.0;\n\t else\n\t  element=1.0;\n\t return element;\n}";
			}
//			case "FuzzySet_Fuzziness":{
//				ret="{\n\n}";
//			}
//			case "FuzzySet_FuzzinessEntropy":{
//				ret="{\n\n}";
//			}
//			case "FuzzySet_Roughness":{
//				ret="{\n\n}";
//			}
//			case "IntervalValuedFuzzySet_MembershipDegree":{
//				ret="{\n\n}";
//			}
//			case "IntervalValuedFuzzySet_Fuzziness":{
//				ret="{\n\n}";
//			}
//			case "IntervalValuedFuzzySet_FuzzyEntropy":{
//				ret="{\n\n}";
//			}
//			case "IntervalValuedFuzzySet_Roughness":{
//				ret="{\n\n}";
//			}
//			case "LFuzzySet_MembershipDegree":{
//				ret="{\n\n}";
//			}
//			case "LFuzzySet_Fuzziness":{
//				ret="{\n\n}";
//			}
//			case "LFuzzySet_FuzzyEntropy":{
//				ret="{\n\n}";
//			}
//			case "LFuzzySet_Roughness":{
//				ret="{\n\n}";
//			}
//			case "IntuitionsticFuzzySet_MembershipDegree":{
//				ret="{\n\n}";
//			}
//			case "IntuitionsticFuzzySet_Fuzzyness":{
//				ret="{\n\n}";
//			}
//			case "IntuitionsticFuzzySet_FuzzyEntropy":{
//				ret="{\n\n}";
//			}
//			case "IntuitionsticFuzzySet_Roughness":{
//				ret="{\n\n}";
//			}
//			case "VagueSet_MembershipDegree":{
//				ret="{\n\n}";
//			}
//			case "VagueSet_Fuzziness":{
//				ret="{\n\n}";
//			}
//			case "VagueSet_FuzzyEntropy":{
//				ret="{\n\n}";
//			}
//			case "VagueSet_Roughness":{
//				ret="{\n\n}";
//			}
//			case "TriangularFuzzyNumber_isSharped":{
//				ret="{\n\n}";
//			}
//			case "TriangularFuzzyNumber_a":{
//				ret="{\n\n}";
//			}
//			case "TriangularFuzzyNumber_b":{
//				ret="{\n\n}";
//			}
//			case "TriangularFuzzyNumber_c":{
//				ret="{\n\n}";
//			}
//			case "TriangularFuzzyNumber_number":{
//				ret="{\n\n}";
//			}
//			case "PignisticDistribution_expression":{
//				ret="{\n\n}";
//			}
			case "ShannonEntropy_h":{
				ret="{\n\t double entropy=0.0;\n\t double count;\n\t int i, length=0, SIZE=256;\n\t length=sizeof(var);\n\t for(i=0; i<SIZE; i++){\n\t  if(var[i]!=0){\n\t   count=(double)var[i] / (double)length;\n\t   entropy+=-count * log2(count);\n\t  }\n\t } return entropy;\n}";
			}
			case "HartleyMeasure_h":{
				ret="{\n\t double hartley=0.0;\n\t int length=0;\n\t length=sizeof(var);\n\t hartley=log10(length);\n\t return hartley;\n}";
			}
//			case "AlternativeMeasure_h":{
//				ret="{\n\n}";
//			}
//			case "U_Uncertainty_h":{
//				ret="{\n\n}";
//			}
//			case "DissonanceMeasure_e":{
//				ret="{\n\n}";
//			}
//			case "DissonanceMeasure_complementary":{
//				ret="{\n\n}";
//			}
//			case "DissonanceMeasure_Conflict":{
//				ret="{\n\n}";
//			}
//			case "BeliefInterval_min":{
//				ret="{\n\t double beliefMin=var[0];\n\t int length=0, i;\n\t length=sizeof(var);\n\t for(i=1; i<length; i++){\n\t  if(beliefMin>var[i])\n\t   beliefMin=var[i];\n\t }\n\t return beliefMin;\n}";
//			}
//			case "BeliefInterval_max":{
//				ret="{\n\t double beliefMax=var[0];\n\t int length=0, i;\n\t length=sizeof(var);\n\t for(i=1; i<length; i++){\n\t  if(beliefMax<var[i])\n\t   beliefMax=var[i];\n\t }\n\t return beliefMax;\n}";
//			}
//		
			//TODO finish 
		}				
		return ret;
	}
	
	

	
	
	def String DistributionManagement(AbstractElement2 element){
		var String ret="calc";
		if(element.uncer1!==null){
			if(element.uncer1.bernoulliDistribution!==null){
				if(element.uncer1.bernoulliDistribution.bernProb!==null){
					ret=ret+"BernoulliDistribution_prob("+element.uncer1.bernoulliDistribution.name+".array)";
				}
				else if(element.uncer1.bernoulliDistribution.bernTrials!==null){
					ret=ret+"BernoulliDistribution_trials("+element.uncer1.bernoulliDistribution.name+".array)";
				}
				
			}
			
			else if(element.uncer1.gammaDistribution!==null){
				if(element.uncer1.gammaDistribution.gammaK!==null){
					ret=ret+"GammaDistribution_K("+element.uncer1.gammaDistribution.name+".array)";
				}
				else if(element.uncer1.gammaDistribution.getGammaMean!==null){
					ret=ret+"GammaDistribution_mean("+element.uncer1.gammaDistribution.name+".array)";
				}
				
			}
			
			else if(element.uncer1.normalDisstribution!==null){
				if(element.uncer1.normalDisstribution.mean!==null){
					ret=ret+"NormalDistribution_mean("+element.uncer1.normalDisstribution.name+".array)";
				}
				else if(element.uncer1.normalDisstribution.normDistStd!==null){
					ret=ret+"NormalDistribution_normDistStd("+element.uncer1.normalDisstribution.name+".array)";
				}
				
			}
			
			else if(element.uncer1.uniformDistribution!==null){
				if(element.uncer1.uniformDistribution.uniformMax!==null){
					ret=ret+"UniformDistribution_Max("+element.uncer1.uniformDistribution.name+".array)";
				}
				else if(element.uncer1.uniformDistribution.uniformMin!==null){
					ret=ret+"UniformDistribution_Min("+element.uncer1.uniformDistribution.name+".array)";
				}
				
			}
			
			else if(element.uncer1.percentage!==null){
				if(element.uncer1.percentage.valuePer!==null){
					ret=ret+"Percentage_value("+element.uncer1.percentage.name+".array)";
				}
			}
		}
		else if(element.uncer2!==null){
			if(element.uncer2.fuzzyInterval!==null){
				if(element.uncer2.fuzzyInterval.maxfuzzyNumber!==null){
					ret=ret+"FuzzyInterval_maxfuzzyNumber("+element.uncer2.fuzzyInterval.name+".array)";
				}
				else if(element.uncer2.fuzzyInterval.minfuzzyNumber!==null){
					ret=ret+"FuzzyInterval_minfuzzyNumber("+element.uncer2.fuzzyInterval.name+".array)";
				}
			}
			else if(element.uncer2.fuzzySetCut!==null){
				if(element.uncer2.fuzzySetCut.fuzzySetCutLam!==null){
					ret=ret+"FuzzySetCut_lambda("+element.uncer2.fuzzySetCut.name+".array)";
				}
				else if(element.uncer2.fuzzySetCut.fuzzySetCutisStr!==null){
					ret=ret+"FuzzySetCut_isStrong("+element.uncer2.fuzzySetCut.name+".array)";
				}
				else if(element.uncer2.fuzzySetCut.fuzzySetCutkin!==null){
					ret=ret+"FuzzySetCut_kind("+element.uncer2.fuzzySetCut.name+".array)";
				}
			}
			else if(element.uncer2.fuzzyLogic!==null){
				if(element.uncer2.fuzzyLogic.fuzzyLogicOpera!==null){
					ret=ret+"FuzzyLogic_operator("+element.uncer2.fuzzyLogic.name+".array)";
				}
				else if(element.uncer2.fuzzyLogic.fuzzyLogicVar!==null){
					ret=ret+"FuzzyLogic_var("+element.uncer2.fuzzyLogic.name+".array)";
				}
				else if(element.uncer2.fuzzyLogic.fuzzyLogicSet!==null){
					if(element.uncer2.fuzzyLogic.fuzzyLogicSet.FLSmembershipDegree!==null){
						ret=ret+"FuzzyLogic_set("+element.uncer2.fuzzyLogic.name+").MembershipDegree("+element.uncer2.fuzzyLogic.fuzzyLogicSet.FLSmembershipDegree.name+".array)";///////////
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet.FLSfuzziness!==null){
						ret=ret+"FuzzyLogic_set.Fuzziness("+element.uncer2.fuzzyLogic.name+".array)";
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet. FLSfuzzyEntropy!==null){
						ret=ret+"FuzzyLogic_set.FuzzyEntropy("+element.uncer2.fuzzyLogic.name+".array)";
					}
					else if(element.uncer2.fuzzyLogic.fuzzyLogicSet. FLSroughness!==null){
						ret=ret+"FuzzyLogic_set.Roughness("+element.uncer2.fuzzyLogic.name+".array)";
					}
				}
			}
			else if(element.uncer2.fuzzySet!==null){
				if(element.uncer2.fuzzySet.FSmembershipDegree!==null){
					if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeValue!==null){
						ret=ret+"FuzzySet_MembershipDegree_value("+element.uncer2.fuzzySet.name+".array)";
					}
					else if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeHedge!==null){
						ret=ret+"FuzzySet_MembershipDegree_hedge("+element.uncer2.fuzzySet.name+".array)";
					}
					else if(element.uncer2.fuzzySet.FSmembershipDegree.membershipDegreeElement!==null){
						ret=ret+"FuzzySet_MembershipDegree_element("+element.uncer2.fuzzySet.name+".array)";
					}
				}
				else if(element.uncer2.fuzzySet.FSfuzziness!==null){
					ret=ret+"FuzzySet_Fuzziness("+element.uncer2.fuzzySet.name+".array)";
				}
				else if(element.uncer2.fuzzySet.FSfuzzyEntropy!==null){
					ret=ret+"FuzzySet_FuzzyEntropy("+element.uncer2.fuzzySet.name+".array)";
				}
				else if(element.uncer2.fuzzySet.FSroughness!==null){
					ret=ret+"FuzzySet_Roughness("+element.uncer2.fuzzySet.name+".array)";
				}	
			}
			else if(element.uncer2.intervalValuedFuzzySet!==null){
				if(element.uncer2.intervalValuedFuzzySet.IVFmembershipDegree!==null){
					ret=ret+"IntervalValuedFuzzySet_MembershipDegree("+element.uncer2.intervalValuedFuzzySet.name+".array)";
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFfuzziness!==null){
					ret=ret+"IntervalValuedFuzzySet_Fuzziness("+element.uncer2.intervalValuedFuzzySet.name+".array)";
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFfuzzyEntropy!==null){
					ret=ret+"IntervalValuedFuzzySet_FuzzyEntropy("+element.uncer2.intervalValuedFuzzySet.name+".array)";
				}
				else if(element.uncer2.intervalValuedFuzzySet.IVFroughness!==null){
					ret=ret+"IntervalValuedFuzzySet_Roughness("+element.uncer2.intervalValuedFuzzySet.name+".array)";
				}	
			}
			else if(element.uncer2.LFuzzySet!==null){
				if(element.uncer2.LFuzzySet.LFSmembershipDegree!==null){
					ret=ret+"LFuzzySet_MembershipDegree("+element.uncer2.LFuzzySet.name+".array)";
				}
				else if(element.uncer2.LFuzzySet.LFSfuzziness!==null){
					ret=ret+"LFuzzySet_Fuzziness("+element.uncer2.LFuzzySet.name+".array)";
				}
				else if(element.uncer2.LFuzzySet.LFSfuzzyEntropy!==null){
					ret=ret+"LFuzzySet_FuzzyEntropy("+element.uncer2.LFuzzySet.name+".array)";
				}
				else if(element.uncer2.LFuzzySet.LFSroughness!==null){
					ret=ret+"LFuzzySet_Roughness("+element.uncer2.LFuzzySet.name+".array)";
				}
			}
			else if(element.uncer2.intuitionisticFuzzySet!==null){
				if(element.uncer2.intuitionisticFuzzySet.IFmembershipDegree!==null){
					ret=ret+"IntuitionisticFuzzySet_MembershipDegree("+element.uncer2.intuitionisticFuzzySet.name+".array)";
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFfuzziness!==null){
					ret=ret+"IntuitionisticFuzzySet_Fuzziness("+element.uncer2.intuitionisticFuzzySet.name+".array)";
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFfuzzyEntropy!==null){
					ret=ret+"IntuitionisticFuzzySet_FuzzyEntropy("+element.uncer2.intuitionisticFuzzySet.name+".array)";
				}
				else if(element.uncer2.intuitionisticFuzzySet.IFroughness!==null){
					ret=ret+"IntuitionisticFuzzySet_Roughness("+element.uncer2.intuitionisticFuzzySet.name+".array)";
				}
			}
			else if(element.uncer2.vagueSet!==null){
				if(element.uncer2.vagueSet.VSmembershipDegree!==null){
					ret=ret+"VagueSet_MembershipDegree("+element.uncer2.vagueSet.name+".array)";
				}
				else if(element.uncer2.vagueSet.VSfuzziness!==null){
					ret=ret+"VagueSet_Fuzziness("+element.uncer2.vagueSet.name+".array)";
				}
				else if(element.uncer2.vagueSet.VSfuzzyEntropy!==null){
					ret=ret+"VagueSet_FuzzyEntropy("+element.uncer2.vagueSet.name+".array)";
				}
				else if(element.uncer2.vagueSet.VSroughness!==null){
					ret=ret+"VagueSet_Roughness("+element.uncer2.vagueSet.name+".array)";
				}
			}
			else if(element.uncer2.triangularFuzzyNumber!==null){
				if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberisSha!==null){
					ret=ret+"TriangularFuzzyNumber_isSharped("+element.uncer2.triangularFuzzyNumber.name+".array)";
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumbera!==null){
					ret=ret+"TriangularFuzzyNumber_a("+element.uncer2.triangularFuzzyNumber.name+".array)";
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberb!==null){
					ret=ret+"TriangularFuzzyNumber_b("+element.uncer2.triangularFuzzyNumber.name+".array)";
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumberc!==null){
					ret=ret+"TriangularFuzzyNumber_c("+element.uncer2.triangularFuzzyNumber.name+".array)";
				}
				else if(element.uncer2.triangularFuzzyNumber.triangularFuzzyNumber!==null){
					ret=ret+"TriangularFuzzyNumber_number("+element.uncer2.triangularFuzzyNumber.name+".array)";
				}
			}
		}
		else if(element.uncer3!==null){
			if(element.uncer3.pignisticDistribution!==null){
				ret=ret+"PignisticDistribution_expression("+element.uncer3.pignisticDistribution.name+".array)";
			}
			else if(element.uncer3.shannonEntropy!==null){
				ret=ret+"ShannonEntropy_h("+element.uncer3.shannonEntropy.name+".array)";
			}
			else if(element.uncer3.hartleyMeasure!==null){
				ret=ret+"HartleyMeasure_h("+element.uncer3.hartleyMeasure.name+".array)";
			}
			else if(element.uncer3.alternativeMeasure!==null){
				ret=ret+"AlternativeMeasure_h("+element.uncer3.alternativeMeasure.name+".array)";
			}
			else if(element.uncer3.u_Uncertainty!==null){
				ret=ret+"U_Uncertainty_h("+element.uncer3.u_Uncertainty.name+".array)";
			}
			else if(element.uncer3.dissonanceMeasure!==null){
				if(element.uncer3.dissonanceMeasure.dissonanceMeasureE!==null){
					ret=ret+"DissonanceMeasure_e("+element.uncer3.dissonanceMeasure.name+".array)";
				}
				else if(element.uncer3.dissonanceMeasure.dissonanceMeasureComplem!==null){
					ret=ret+"DissonanceMeasure_complementray("+element.uncer3.dissonanceMeasure.name+".array)";
				}
				else if(element.uncer3.dissonanceMeasure.conflict!==null){
					ret=ret+"DissonanceMeasure_Conflict("+element.uncer3.dissonanceMeasure.name+".array)";
				}
			}
			else if(element.uncer3.distribution!==null){
				ret=ret+"Distribution_expression("+element.uncer3.distribution.name+".array)";
			}
			else if(element.uncer3.beliefInterval!==null){
				if(element.uncer3.beliefInterval.min!==null){
					ret=ret+"BeliefInterval_min("+element.uncer3.beliefInterval.name+".array)";
				}
				else if(element.uncer3.beliefInterval.max!==null){
					ret=ret+"BeliefInterval_max("+element.uncer3.beliefInterval.name+".array)";
				}
			}
			else if(element.uncer3.possibleDistribution!==null){
				ret=ret+"PossibleDistribution_expression("+element.uncer3.beliefInterval.name+".array)";
			}
		}
		
		return ret;
	}
	
}


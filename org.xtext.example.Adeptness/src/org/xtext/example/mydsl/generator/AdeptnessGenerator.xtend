/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import com.google.inject.Inject
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.example.mydsl.adeptness.Oracle
import org.xtext.example.mydsl.adeptness.Signal
import org.xtext.example.mydsl.adeptness.ValidationPlan

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AdeptnessGenerator extends AbstractGenerator {
 @Inject extension IQualifiedNameProvider

	//Poner el directorio de la seinal, donde se van a generar los .c y .h para poder compilarlo en matlab y generar el .mex file
	//String directory="C:\\Users\\hazibek02\\runtime-EclipseXtext\\Matlab\\src-gen\\lehenengoa\\"; 
var HashMap<String, List<String>> nameMap;
var HashMap<String, String> whenMap;
var HashMap<String, String> whileMap;
var HashMap<String, String> whenMap_preconds;
var HashMap<String, String> whileMap_preconds;
    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    	//fsa.generateFile("adeptness.xml", resource.allContents.toIterable.filter(Signal).createXML());
    		for(a: resource.allContents.toIterable.filter(ValidationPlan)){
    			fsa.generateFile(a.fullyQualifiedName.toString("/")+".json", a.create_VP_json())
    		}
      		for(e: resource.allContents.toIterable.filter(Signal)){
       	
			/*for(f: e.check_range){
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".c", f.create_range_c())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".h", f.create_range_h())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".m", f.create_range_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+f.name.toString+"')");
			}
			for (u: e.check_gap){
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".c", u.create_gap_c())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".h", u.create_gap_h())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".m", u.create_gap_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+u.name.toString+"')");
			}
			for(l: e.check_static_lower){
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".c", l.create_low_c())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".h", l.create_low_h())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".m", l.create_low_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+l.name.toString+"')");
			}
			for(d: e.check_static_upper){
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".c", d.create_up_c())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".h", d.create_up_h())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".m", d.create_up_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}*/
			nameMap= new HashMap();
			whenMap=new HashMap();
			whileMap= new HashMap();
			whileMap_preconds= new HashMap();
			whenMap_preconds= new HashMap();
			getAllNames(e);
			for(q: e.oracle){
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".c", q.create_oracle_c(nameMap.get(q.name)))
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".h", q.create_oracle_h(nameMap.get(q.name)))
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".json", q.create_oracle_json())
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".m", q.create_oracle_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}
			fsa.generateFile(e.fullyQualifiedName.toString("/")+".json", e.create_oracle_json())
			
		}
    }
	
	def create_VP_json(ValidationPlan plan)'''
	{
	«"\t"»"tests" : {
	«FOR test: plan.test»
	«"\t\t"»"«test.name»" : {
	«"\t\t\t"»"SUT": "«test.sut»" ,
	«"\t\t\t"»"TestLevel": "«test.testLevel»" ,
	«"\t\t\t"»"inputs": «FOR input : test.inputs» "«input.value»", «ENDFOR»
	«"\t\t\t"»"oracles": {«FOR oracle: test.oracles»
	«"\t\t\t\t"»"«oracle.name»" :{
	«"\t\t\t\t\t"»"type": "«oracle.type»",
	«"\t\t\t\t\t"»"prams": «FOR param: oracle.parameters»"«FOR param1: param.value.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ELSEIF parent.elements!==null» «parent.elements.op»«ENDIF»«ENDFOR»«ENDFOR»,"«ENDFOR»
	«"\t\t\t\t"»},
	«ENDFOR»
	«"\t\t\t"»},
	«"\t\t"»},
	«ENDFOR»
	«"\t"»}
	}
	'''
	
	def getAllNames(Signal signal) {
		var List<String> namelists;
		var List<String> whileNames;
		var List<String> whenNames;
		var Oracle oracle;
		var boolean is;
		for(var z=0; z< signal.oracle.size; z++){
			oracle=signal.oracle.get(z);
			namelists=new ArrayList();
			is=false;
			if(oracle.check.em!==null){
				for(var i=0; i< oracle.check.em.elements.size; i++){
					
					for(var j=0; j<namelists.size;j++){
						if(oracle.check.em.elements.get(i).name===null ||(namelists.get(j)!==null && namelists.get(j).equals(oracle.check.em.elements.get(i).name)) || oracle.check.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is && oracle.check.em.elements.get(i).name!==null){
						namelists.add(oracle.check.em.elements.get(i).name);
					}
					else{
						is=false;
					}
				}
			}
			else{
				namelists.add(oracle.check.name);
			}
			is=false;
			if(oracle.^while!==null){
				whileNames= new ArrayList();
				var wile=oracle.^while;
				var isWHile=false;
				for (var i=0; i<wile.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(wile.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(wile.em.elements.get(i).name);
						
					}
					else{
						is=false;
					}
					for(var j=0; j<whileNames.size;j++){
						if(wile.em.elements.get(i).name===null || (whileNames.get(j)!==null && whileNames.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							isWHile=true;
						}
					}
					if(!isWHile){
						whileNames.add(wile.em.elements.get(i).name);
						
					}
					else{
						isWHile=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whileNames.size; i++){
					if(i!=whileNames.size-1){
						a=a+"int "+whileNames.get(i)+", ";
						b=b+whileNames.get(i)+"[cycle], ";
					}
					else{
						a=a+"int "+whileNames.get(i);
						b=b+whileNames.get(i)+"[cycle] ";
					}
				}
				println(a);
				whileMap.put(oracle.name,a);
				whileMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.when!==null){
				whenNames= new ArrayList();
				var isWhen= false;
				var when=oracle.when;
				for (var i=0; i<when.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(when.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(when.em.elements.get(i).name);
					}
					else{
						is=false;
					}
					for(var j=0; j<whenNames.size;j++){
						if(when.em.elements.get(i).name===null || (whenNames.get(j)!==null && whenNames.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							isWhen=true;
						}
					}
					if(!isWhen){
						whenNames.add(when.em.elements.get(i).name);
					}
					else{
						isWhen=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whenNames.size; i++){
					if(i!=whenNames.size-1){
						a=a+"int "+whenNames.get(i)+", ";
						b=b+whenNames.get(i)+"[cycle], ";
					}
					else{
						a=a+"int "+whenNames.get(i);
						b=b+whenNames.get(i)+"[cycle]";
					}
				}
				whenMap.put(oracle.name,a);
				whenMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.check.reference!==null){
				if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
			
				else if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.upper!==null && oracle.check.reference.upper.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.upper.bound_upp.em.elements.size; i++){
						
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.same!==null && oracle.check.reference.same.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.same.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.notsame!==null && oracle.check.reference.notsame.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.notsame.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference!==null){
					if(oracle.check.reference.lower!==null && oracle.check.reference.lower.bound_lower.em!==null){
						for(var i=0; i<oracle.check.reference.lower.bound_lower.em.elements.size; i++){
							for(var j=0; j<namelists.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							namelists.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
						}
					}
				}
				
			}
				
			nameMap.put(oracle.name, namelists);
		}
	}
		
	/*def createXML(Iterable<Signal> signals)'''
	<?xml version='1.0' encoding="UTF-8"?>
		«FOR s : signals»
			<Signal>
				<SignalDescription name="«s.fullyQualifiedName.toString("/")»">
					<TypeSignalDescription name="Static">
						«FOR c: s.check_gap»
							<Type name="«c.name.toString»">
								<Parameters>
									<«c.inclusive_bound.eClass.name.toString()»>«c.inclusive_bound.value.bool»</«c.inclusive_bound.eClass.name.toString()»>
									<«c.bound_up.eClass.name.toString()»>«c.bound_up.value.DVal»</«c.bound_up.eClass.name.toString()»>
									<«c.bound_low.eClass.name.toString()»>«c.bound_low.value.DVal»</«c.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Low">
						«FOR l: s.check_static_lower»
							<Type name="«l.name.toString»">
								<Parameters>
									<«l.inclusive_bound.eClass.name.toString()»>«l.inclusive_bound.value.bool»</«l.inclusive_bound.eClass.name.toString()»>
									<«l.bound_low.eClass.name.toString()»>«l.bound_low.value.DVal»</«l.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Up">
						«FOR u: s.check_static_upper»
							<Type name="«u.name.toString»">
								<Parameters>
									<«u.inclusive_bound.eClass.name.toString()»>«u.inclusive_bound.value.bool»</«u.inclusive_bound.eClass.name.toString()»>
									<«u.bound_up.eClass.name.toString()»>«u.bound_up.value.DVal»</«u.bound_up.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Dynamic">
						«FOR d: s.check_range»
							<Type name="«d.name.toString»">
								<Parameters>
									<«d.inclusive_bound.eClass.name.toString()»>«d.inclusive_bound.value.bool»</«d.inclusive_bound.eClass.name.toString()»>
									<«d.bound_up.eClass.name.toString()»>«d.bound_up.value.DVal»</«d.bound_up.eClass.name.toString()»>
									<«d.bound_low.eClass.name.toString()»>«d.bound_low.value.DVal»</«d.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>		
						«ENDFOR»
					</TypeSignalDescription>						
				</SignalDescription>
			</Signal>
		«ENDFOR»
	'''*/
	
	
	/*def create_oracle_m(Oracle param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''*/
	//Expresions in values check
	def CharSequence create_oracle_json(Signal CPS)'''
	«var cont=0»
	{
		"Name":"«CPS.name»",
	«FOR param: CPS.oracle»
			"«param.name»":{
				"cfileDirectory":"«param.fullyQualifiedName.toString("/")+".c"»",
				"hfileDirectory":"«param.fullyQualifiedName.toString("/")+".h"»",
				«"\t\t"»"Inputs":[«FOR name:nameMap.get(param.name)»"«name»", «ENDFOR»"timeStamp"],
			«"\t"»"While":"«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ELSE»null",«ENDIF»
			«"\t"»"When":{
				«"\t"»"Value":"«IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ELSE»null",«ENDIF»
				«"\t"»"AfterWhen":{
				«IF param.when!==null»
					«IF param.when.aw!==null»
						«IF param.when.aw.during!==null»
					«"\t"»"Type":"During",
					«"\t"»"Value":"«param.when.aw.during.time.DVal»",
					«"\t"»"Unit":"«param.when.aw.during.unit.time»"
						«ELSEIF param.when.aw.getWait!==null»
					«"\t"»"Type":"Wait",
					«"\t"»"Value":"«param.when.aw.getWait.time.DVal»",
					«"\t"»"Unit":"«param.when.aw.getWait.unit.time»"
						«ENDIF»
					«ELSE»
					«"\t"»"Type":"null",
					«"\t"»"Value":"null",
					«"\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t"»"Type":"null",
					«"\t"»"Value":"null",
					«"\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t"»},
		«IF param.check.name!==null»
			«"\t\t"»"Check":"«param.check.name» ",
		«ELSE»
			«"\t\t"»"Check":" «FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op»«ELSEIF parent.elements!==null»«parent.elements.op» «ENDIF»«ENDFOR» «ENDFOR»",
		«ENDIF»
		«IF param.check.reference.lower!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Above",
				«"\t\t"»"Value":["«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»"],«ELSE»«FOR param1: param.check.reference.lower.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ELSEIF parent.elements!==null»«parent.elements.op»«ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.lower.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.lower.exactly.value.DVal»",
					«IF param.check.reference.lower.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.exactly.unit.time»"
					«ELSE»
							«"\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.lower.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.lower.atleast.value.DVal»",
					«IF param.check.reference.lower.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.lower.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.lower.atmost.value.DVal»",
					«IF param.check.reference.lower.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.upper!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Below",
				«"\t\t"»"Value":["«IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.upper.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.upper.exactly!==null»
				«"\t\t\t"»	"Type":"exactly",
				«"\t\t\t"»	"Value":"«param.check.reference.upper.exactly.value.DVal»",
					«IF param.check.reference.upper.exactly.time!==null»
						«"\t\t\t"»	"Time":"«param.check.reference.upper.exactly.time.DVal»",
						«"\t\t\t"»	"Unit":"«param.check.reference.upper.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.upper.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.upper.atleast.value.DVal»",
					«IF param.check.reference.upper.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.upper.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.upper.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.upper.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.upper.atmost.value.DVal»",
					«IF param.check.reference.upper.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.upper.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.upper.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.range!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Range",
				«"\t\t"»"Value":["«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»",«ELSE»«FOR param1: param.check.reference.range.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.range.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.range.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.range.exactly.value.DVal»",
					«IF param.check.reference.range.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.range.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.range.atleast.value.DVal»",
					«IF param.check.reference.range.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.range.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.range.atmost.value.DVal»",
					«IF param.check.reference.range.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.gap!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Gap",
				«"\t\t"»"Value":["«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»",«ELSE»«FOR param1: param.check.reference.gap.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value»"],«ELSE»«FOR param1: param.check.reference.gap.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.gap.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.gap.exactly.value.DVal»",
					«IF param.check.reference.gap.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.gap.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.gap.atleast.value.DVal»",
					«IF param.check.reference.gap.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.gap.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.gap.atmost.value.DVal»",
					«IF param.check.reference.gap.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.same!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Same",
				«"\t\t"»"Value":["«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.same.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.same.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.same.exactly.value.DVal»",
					«IF param.check.reference.same.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.exactly.unit.time»"
					«ELSE»
							«"\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.same.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.same.atleast.value.DVal»",
					«IF param.check.reference.same.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.same.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.same.atmost.value.DVal»",
					«IF param.check.reference.same.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.notsame!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"NotSame",
				«"\t\t"»"Value":["«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.notsame.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.notsame.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.exactly.value.DVal»"
					«IF param.check.reference.notsame.exactly.time!==null»
						«"\t\t\t"»	"Time":"«param.check.reference.notsame.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.notsame.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.atleast.value.DVal»"
					«IF param.check.reference.notsame.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.notsame.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.notsame.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.atmost.value.DVal»"
					«IF param.check.reference.notsame.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.notsame.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ENDIF»
		«FOR failreason: param.check.failReason»
			«"\t\t"»"FailReason":{
		«IF failreason.reason.highPeak!==null»
				«"\t"»"Type":"HighPeak",
				«"\t"»"Cant":"«failreason.reason.highPeak.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"null",
				«"\t"»"Unit":"null"
		«ELSEIF failreason.reason.highTime!==null»
				«"\t"»"Type":"HighTime",
				«"\t"»"Cant":"«failreason.reason.highTime.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"«failreason.reason.highTime.time.DVal»",
				«"\t"»"Unit":"«failreason.reason.highTime.unit.time»"
		«ELSEIF failreason.reason.XPeaks!==null»
				«"\t"»"Type":"XPeaks",
				«"\t"»"Cant":"«failreason.reason.XPeaks.cant.DVal»",
				«"\t"»"NPeaks":"«failreason.reason.XPeaks.NPeaks.DVal»",
				«"\t"»"Time":"«failreason.reason.XPeaks.time.DVal»",
				«"\t"»"Unit":"«failreason.reason.XPeaks.unit.time»"
		«ELSEIF failreason.reason.constDeg!==null»
				«"\t"»"Type":"ConstantDegradation",
				«"\t"»"Cant":"«failreason.reason.constDeg.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"null",
				«"\t"»"Unit":"null"
		«ENDIF»
			«"\t\t"»},
		«ENDFOR»
			«"\t"»"Description":"«param.check.description.value»"
		«IF (cont++)!=CPS.oracle.size-1»
			«"\t"»},
		«ELSE»
			«"\t"»}
		«ENDIF»
	«ENDFOR»
	}
	
	'''
	def create_oracle_h(Oracle param, List<String> nameList)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	struct Verdict{
		
	}VERDICT;
	struct SensorInput{
		
	}SENSOR_INPUT, *SENSOR_INPUT;
	int preprocessInputs(SensorInput *inputs, int inputQty);
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs, int inputQty);
	Verdict performEvaluation_«param.name»(SensorInput *inputs, int inputQty, double timeStamp);
	
	«IF param.check.reference.upper!==null»
	struct Ret{
		int assert;
		double diff;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
	«ELSEIF param.check.reference.lower!==null»
	struct Ret{
		int assert;
		double diff;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
		«ELSEIF param.check.reference.same!==null»
	struct Ret{
		int assert;
		double diff;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
		«ELSEIF param.check.reference.notsame!==null»
	struct Ret{
		int assert;
		double diff;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
		«ELSEIF param.check.reference.range!==null»
	struct Ret{
		int assert;
		double diff_up;
		double diff_down;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
		«ELSEIF param.check.reference.gap!==null»
	struct Ret{
		int assert;
		double diff_up;
		double diff_down;
	};
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]);
		«ENDIF»
		
	
	#endif
	'''	
	/*«IF param.when!==null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
						
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
						
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when===null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when!==null && param.^while===null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
						
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);			
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]);
			«ENDIF»
		«ENDIF»
	«ELSE»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]);			
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]);
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);
			«ELSEIF param.check.reference.lower!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);
			«ELSEIF param.check.reference.same!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret{
				int assert;
				double diff;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);				
			«ELSEIF param.check.reference.range!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);
			«ELSEIF param.check.reference.gap!==null»
			struct Ret{
				int assert;
				double diff_up;
				double diff_down;
			};
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]);
			«ENDIF»
		«ENDIF»
	«ENDIF» */
	def create_oracle_c(Oracle param,List<String> nameList)
	'''
	#include "«param.name.toString()».h"
	//«param.check.description.value»
	int preprocessInputs(SensorInput *inputs, int inputQty) {
		//TODO.
	    return inputQty;
	}
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF») {
		return «IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.elements!==null» «parent.elements.op»«ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»;
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs, int inputQty) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs, int inputQty, double timeStamp){
	    Verdict verdict;
		//Step 1: inicializacion
	    Static int cycle = -1;
		Static double[] timeStampOracle; 
		«FOR param1: nameMap.get(param.name)»
		Static int[] «param1»;
		«ENDFOR»
		Static double[] conf;
		Static int[] preconditionGiven;
	
		//Step 2: meter variables en array
		cycle++;
		timeStampOracle[cycle] = timeStamp;
		«FOR param1: nameMap.get(param.name)»
		«param1»[cycle]=getCurrentIntValueFromInputs(inputs,"«param1»");
		«ENDFOR»
		«IF param.when!==null || param.^while!==null»
		preconditionGiven[cycle] = evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap_preconds.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap_preconds.get(param.name).toString»«ENDIF»);	
		«ENDIF»
		
		//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
		if(preconditionGiven[cycle]){
			
			//--During balidn bada, TimeStamp erabili, horretarako timeStamp-a beti ms-tan satru ezkero kalkulatu daiteke zenbat timeStamp behar ditugu honen konfidentzia jakiteko.
			//Adibidea: timeStamp= 2 ms (timeStampOracle[1]-timeStampOracle[0])=timeStamp. IterazioKopurua=During/timeStamp eta horrarte kalkulatu conf-a.
			//if(preconditionGiven[cycle] && during>0) during baldin bada hasieratuta 1-era egongo da, bestela 0-ra. Kasuistika baten during ez bada erabiltzen 1-era hasieratu ta listo.
			conf[cycle] = llamadaAFuncionParaComprobarEsto(preconditionGiven[cycle]);//--funcion global y pasarle los valores y referencia a checkear con el tipo de check?
		}else{
			
			conf[cycle] = 2;
		}
		
		//Step 4: Sacar confidence
		
		//GLOBAL?
		verdict = checkGlobalVerdict(conf/*failureType, refValue*/); 
		
		
	    return verdict;
	}
	
	«IF param.check.reference.upper!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.lower!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.same!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.notsame!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.range!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.gap!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ENDIF»
		struct Ret ret;
		return ret;
	}
	'''
	
	/*
	 «IF param.when!==null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when===null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){				
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» (double «param.check.name.toString()»[], «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){				
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when!==null && param.^while===null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSE»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ENDIF» 
	 
	 
	 def create_oracle_c(Oracle param)'''
	#include "«param.name.toString()».h"
	«FOR param1: param.check»
		//Comment: «param1.description.value.toString»'''
		«IF param1.reference.upper!==null»
		struct Ret BelowReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.upper.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.value.DVal»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.name.toString»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ELSEIF param1.reference.lower!==null»
		struct Ret AboveReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.lower.bound_lower.value!==null»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.value.DVal»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.name.toString»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.range!==null»
		struct Ret RangeReference (double «param1.name.toString»){
			struct Ret ret;
			
			«IF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSEIF param1.reference.range.bound_lower.value===null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ELSEIF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value===null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.gap!==null»
		struct Ret GapReference (double «param1.name.toString()»){
			struct Ret ret;
			«IF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value===null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value===null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ENDIF»
			return ret;
		}
	«ENDFOR»
		

	'''*/
	

	
	/*def create_up_m(Check_Static_upper_only param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	def create_up_h(Check_Static_upper_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_up_c(Check_Static_upper_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <=«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input <«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''
	
	def create_low_m(Check_Static_lower_only param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_low_h(Check_Static_lower_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_low_c(Check_Static_lower_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal»){
				ret=1;
			}
		«ENDIF»
		return ret;
	}
	'''
	
	def create_range_m(Check_Range param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_range_h(Check_Range param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_range_c(Check_Range param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal» && Input <= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal» && Input < «param.bound_up.value.DVal» ){
						ret=1;
			}	
		«ENDIF»
		return ret;		
			
	}
	'''
	
	def create_gap_m(Check_Gap param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_gap_h(Check_Gap param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_gap_c(Check_Gap param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <= «param.bound_low.value.DVal» || Input >= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input < «param.bound_low.value.DVal» || Input > «param.bound_up.value.DVal» ){
							ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''*/
}

/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import com.google.inject.Inject
import com.oracle.truffle.js.scriptengine.GraalJSEngineFactory
import java.io.File
import java.io.FileNotFoundException
import java.io.FileWriter
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.List
import java.util.Scanner
import java.util.Set
import javax.script.ScriptException
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.example.mydsl.adeptness.AbstractElement2
import org.xtext.example.mydsl.adeptness.CustomOracle
import org.xtext.example.mydsl.adeptness.FailReason
import org.xtext.example.mydsl.adeptness.MonitoringInferVariables
import org.xtext.example.mydsl.adeptness.MonitoringPlan
import org.xtext.example.mydsl.adeptness.Operators
import org.xtext.example.mydsl.adeptness.Oracle
import org.xtext.example.mydsl.adeptness.Signal
import java.util.HashSet

/**
 * Generates code from your model files on save.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AdeptnessGenerator extends AbstractGenerator {
 @Inject extension IQualifiedNameProvider

	//Poner el directorio de la seinal, donde se van a generar los .c y .h para poder compilarlo en matlab y generar el .mex file
	String directory="C:\\Users\\pablo\\OneDrive\\Escritorio\\trabajo\\runtime-EclipseXtext\\Pruebas\\src-gen\\"; 
var HashMap<String, List<String>> nameMap;
var HashMap<String, String> whenMap;
var HashMap<String, String> whileMap;
var HashMap<String, String> whenMap_preconds;
var HashMap<String, String> whileMap_preconds;
var HashMap<String, Double> maxMap;
var HashMap<String, Double> minMap;
var HashMap<String, List<String>> checkVar;
var List<String> verdict;
var List<String> first;
var Set<String> predAndCheckInputs;
var CharSequence confCalculationBody;
    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    	
      	for(e: resource.allContents.toIterable.filter(Signal)){
       	
			
			nameMap= new HashMap();
			whenMap=new HashMap();
			whileMap= new HashMap();
			whileMap_preconds= new HashMap();
			whenMap_preconds= new HashMap();
			checkVar= new HashMap();
			maxMap= new HashMap();
			minMap= new HashMap();
			getAllNames(e);
			findSignalsMaxMinValues(e);
			for(v:e.superType.monitoringInferVariables){
			
				fsa.generateFile(e.name+"/"+v.name+".c",v.create_infer_c())
				fsa.generateFile(e.name+"/"+v.name+".h",v.create_infer_h())
				fsa.generateFile(e.name+"/gen_model_for_"+v.name+".py", v.create_model_py())
				
			}
			for(q: e.oracle){
				verdict= new ArrayList();
				first= new ArrayList();
				
				q.create_verdict_c(nameMap.get(q.name));
				confCalculationBody=q.confCalculation(nameMap.get(q.name));
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".c", q.create_oracle_c(nameMap.get(q.name)))
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".h", q.create_oracle_h(nameMap.get(q.name),e.fullyQualifiedName.toString()))
				
				//appendFile(e,q.fullyQualifiedName.toString("/")+".c",q.fullyQualifiedName.toString("/")+"_Verdict.c")
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".json", q.create_oracle_json())
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".m", q.create_oracle_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}
			for(co:e.customOracle){
				predAndCheckInputs= new HashSet();
				co.getPredAndCheckInputs();
				fsa.generateFile(co.fullyQualifiedName.toString("/")+".c", co.create_C_oracle_c())
				fsa.generateFile(co.fullyQualifiedName.toString("/")+".h", co.create_C_oracle_h(e.fullyQualifiedName.toString()))
				
			}
			fsa.generateFile(e.fullyQualifiedName.toString("/")+".json", e.create_oracle_json())
			fsa.generateFile("Array.h", e.create_array_h())
			fsa.generateFile("Array.c", e.create_array_c())
			fsa.generateFile(e.fullyQualifiedName.toString()+".h", e.create_global_h())
			
		}
    }
	
	def void getPredAndCheckInputs(CustomOracle oracle){
		if(oracle.precondition!==null){
			for(name: oracle.predInputs){
				predAndCheckInputs.add(name);
			}
		}
		for(name :oracle.checkInputs){
			predAndCheckInputs.add(name);
		}
	}
		
	
	
	
	def confCalculation(Oracle param, List<String> strings)'''
	«IF param.check.reference.upper!==null»
	if(signal<«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf= («IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else{
		conf= («IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.upper.bound_upp.value!==null»«IF param.check.reference.upper.bound_upp.value.DVal>=0»«param.check.reference.upper.bound_upp.value.DVal»«ELSE»(«param.check.reference.upper.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.lower!==null»
	if(signal>«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			
		conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	else{
		conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.lower.bound_lower.value!==null»«IF param.check.reference.lower.bound_lower.value.DVal>=0»«param.check.reference.lower.bound_lower.value.DVal»«ELSE»(«param.check.reference.lower.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	«ELSEIF param.check.reference.same!==null»
	if(signal==«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=1;
	}
	else if(signal<«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.same.bound_upp.value!==null»«IF param.check.reference.same.bound_upp.value.DVal>=0»«param.check.reference.same.bound_upp.value.DVal»«ELSE»(«param.check.reference.same.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.notsame!==null»
	if(signal==«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=-1;
	}
	else if(signal<«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.notsame.bound_upp.value!==null»«IF param.check.reference.notsame.bound_upp.value.DVal>=0»«param.check.reference.notsame.bound_upp.value.DVal»«ELSE»(«param.check.reference.notsame.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ELSEIF param.check.reference.range!==null»
	if(signal<«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
		conf=(«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
	}
	else if(signal>«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
		conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
	}
	else if(signal<«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.range.bound_lower.value!==null»«IF param.check.reference.range.bound_lower.value.DVal>=0»«param.check.reference.range.bound_lower.value.DVal»«ELSE»(«param.check.reference.range.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
	}
	else if(signal>«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
		conf=(«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«maxMap.get(param.name)»-«IF param.check.reference.range.bound_upp.value!==null»«IF param.check.reference.range.bound_upp.value.DVal>=0»«param.check.reference.range.bound_upp.value.DVal»«ELSE»(«param.check.reference.range.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
	}
	«ENDIF»
	'''
	
	def create_model_py(MonitoringInferVariables plan)'''
	import matplotlib.pyplot as plt
	import numpy as np
	import pandas as pd
	import seaborn as sns
	
	# Make numpy printouts easier to read.
	np.set_printoptions(precision=3, suppress=True)
	
	import tensorflow as tf
	
	from tensorflow import keras
	from tensorflow.keras import layers
	from tensorflow.keras.layers.experimental import preprocessing
	
	def plot_loss(history):
	    plt.plot(history.history['loss'], label='loss')
	    plt.plot(history.history['val_loss'], label='val_loss')
	    plt.ylim([0, 10])
	    plt.xlabel('Epoch')
	    plt.ylabel('Error [«plan.name»]')
	    plt.legend()
	    plt.grid(True)
	    plt.show()
	
	def plot_results(test_labels, test_predictions):
	    plt.axes(aspect='equal')
	    plt.scatter(test_labels, test_predictions)
	    plt.xlabel('True Values [MPG]')
	    plt.ylabel('Predictions [MPG]')
	    lims = [0, 50]
	    plt.xlim(lims)
	    plt.ylim(lims)
	    _ = plt.plot(lims, lims)
	    plt.show()
	
	    error = test_predictions - test_labels
	    plt.hist(error, bins=25)
	    plt.xlabel('Prediction Error [MPG]')
	    _ = plt.ylabel('Count')
	    plt.show()
	
	def get_linear_model(train_features, train_labels):
	
	    linear_model = tf.keras.Sequential([
	        tf.keras.layers.InputLayer(input_shape=(2,)),
	        layers.Dense(units=1)
	    ])
	
	
	    linear_model.compile(
	        optimizer=tf.optimizers.Adam(learning_rate=0.1),
	        loss='mean_absolute_error'
	    )
	
	    linear_model.summary()
	
	    history = linear_model.fit(
	        train_features, train_labels, 
	        epochs=100,
	        # suppress logging
	        verbose=0,
	        # Calculate validation results on 20% of the training data
	        validation_split = 0.2
	    )
	
	    plot_loss(history)
	
	    return linear_model
	
	def get_dnn_model(train_features, train_labels):
	
	    model = keras.Sequential([
	        tf.keras.layers.InputLayer(input_shape=(2,)),
	        layers.Dense(64, activation='relu'),
	        layers.Dense(32, activation='relu'),
	        layers.Dense(16, activation='relu'),
	        layers.Dense(32, activation='relu'),
	        layers.Dense(64, activation='relu'),
	        layers.Dense(1)
	    ])
	
	    model.compile(
	        loss='mean_absolute_error',
	        optimizer=tf.keras.optimizers.Adam(0.001)
	    )
	
	    model.summary()
	
	    history = model.fit(
	        train_features,
	        train_labels,
	        validation_split=0.2,
	        verbose=0,
	        epochs=100
	    )
	
	    plot_loss(history)
	
	    return model
	
	def main():
	    print(tf.__version__)
	
	#THIS MUST BE FILLED BY THE USER
	    filenames = [
	        
	    ]
	
	    colnames = [
	        «FOR a:plan.variables»
	        '«a.toString»',
	        «ENDFOR»
	        '«plan.name»'
	    ]
	
	    raw_dataset = pd.DataFrame()
	
	    for filename in filenames:
	        one_dataset = pd.read_csv(
	            f'data/{filename}.csv',
	            names=colnames,
	            na_values='NaN',
	            sep=',',
	            skipinitialspace=True
	        )
	        one_dataset['dataset'] = filename
	        raw_dataset = pd.concat([raw_dataset, one_dataset])
	
	    dataset = raw_dataset.copy()
	    print(dataset.tail())
	
	    dataset = dataset.dropna()
	
	    #for filename in filenames:
	    filename = filenames[0]
	    print(f"\n\n==============  {filename}  ==============\n\n")
	    # train_dataset = dataset.sample(frac=0.8, random_state=0)
	    test_dataset = dataset[dataset['dataset'] == filename]
	    train_dataset = dataset.drop(test_dataset.index)
	
	    print(train_dataset.describe().transpose())
	
	    selected_columns = [
	        «FOR a:plan.variables»
	        '«a.toString»',
	        «ENDFOR»
	        '«plan.name»'
	    ]
	
	    train_features = train_dataset[selected_columns].copy()
	    test_features = test_dataset[selected_columns].copy()
	
	    train_labels = train_features.pop('«plan.name»')
	    test_labels = test_features.pop('«plan.name»')
	
	    test_results = {}
	
	    linear_model = get_linear_model(
	        train_features,
	        train_labels
	    )
	
	    test_results['linear_model'] = linear_model.evaluate(
	        test_features,
	        test_labels,
	        verbose=0
	    )
	
	    dnn_model = get_dnn_model(
	        train_features,
	        train_labels
	    )
	
	    test_results['dnn_model'] = dnn_model.evaluate(
	        test_features,
	        test_labels,
	        verbose=0
	    )
	
	    print(pd.DataFrame(test_results, index=['Mean absolute error [«plan.name»]']).T)
	
	    test_predictions = dnn_model.predict(test_features).flatten()
	
	    plot_results(test_labels, test_predictions)
	
	    dnn_model.save('«plan.model»')
	
	#IGUAL HAU KENDU DAITEKE
	    input_data = np.array([[
	        6.0,
	        0.0
	    ]], dtype=np.float32)
	    output_data = dnn_model.predict(input_data).flatten()
	    print(input_data)
	    print(output_data)
	
	
	if __name__ == "__main__":
	    # execute only if run as a script
	    main()
	
	'''
	
	def create_infer_c(MonitoringInferVariables plan)'''
	#include "«plan.name.toUpperCase».h"
	#include "tensorflow/lite/c/c_api.h"
	
	void infer_«plan.name.toUpperCase»(SensorInput *inputs){
	
	    float input [«plan.variables.size»];
	    float output [1];
	
	    // ------- DSL ---------
	    TfLiteModel* model =
	        TfLiteModelCreateFromFile("./«plan.model»");
	    // ---------------------
	
	    TfLiteInterpreterOptions* options =
	        TfLiteInterpreterOptionsCreate();
	    TfLiteInterpreterOptionsSetNumThreads(options, 1);
	
	    TfLiteInterpreter* interpreter =
	        TfLiteInterpreterCreate(model, options);
	
	    TfLiteInterpreterAllocateTensors(interpreter);
	
	    TfLiteTensor* input_tensor =
	        TfLiteInterpreterGetInputTensor(interpreter, 0);
	
	    // ------- DSL ---------
	    «FOR a:plan.variables»
	    input[«plan.variables.indexOf(a)»] = inputs->«a.toString»;
	    «ENDFOR»
	    // ---------------------
	  
	    TfLiteTensorCopyFromBuffer(
	        input_tensor,
	        input,
	        sizeof(input)
	    );
	
	    TfLiteInterpreterInvoke(interpreter);
	
	    const TfLiteTensor* output_tensor =
	        TfLiteInterpreterGetOutputTensor(interpreter, 0);
	    TfLiteTensorCopyToBuffer(
	        output_tensor, output, sizeof(output)
	    );
	
	    // ------- DSL ---------
	    inputs->«plan.name» = output[0];
	    // ---------------------
	
	    TfLiteInterpreterDelete(interpreter);
	    TfLiteInterpreterOptionsDelete(options);
	    TfLiteModelDelete(model);
	
	}
	
	'''
	def create_infer_h(MonitoringInferVariables plan)'''
	#ifndef «plan.name.toUpperCase»_H
	#define «plan.name.toUpperCase»_H
	
	#include "oracle_commons.h"
	
	void infer_«plan.name.toUpperCase»(SensorInput *inputs);
	
	#endif
	
	'''
	
	def findSignalsMaxMinValues(Signal s){
		
		for(Oracle o: s.oracle){
			if(o.check.em!==null){
				var List<Double> listadoCombinaciones=calcCombinations(o, s.superType.monitoringPlan, s.superType.monitoringInferVariables);
				maxMap.put(o.name,Collections.max(listadoCombinaciones));
				minMap.put(o.name,Collections.min(listadoCombinaciones));
			}
			else{
				var max=0.0;
				var min=0.0;
				for(MonitoringPlan a:s.superType.monitoringPlan){
					if(a.monitoringVariables.name.equals(o.check.name)){
						if(a.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
							max=1.0;
							min=0.0;
						}
						else{
							max=a.monitoringVariables.max.DVal;
							min=a.monitoringVariables.min.DVal;
						}
					}
				}
				maxMap.put(o.name,max);
				minMap.put(o.name,min);
			}
		}
	}
	
	def calcCombinations(Oracle oracle, EList<MonitoringPlan> list,EList<MonitoringInferVariables> listInfer) {
		var String expresionWithVars=getExpressionWithVars(oracle.check.em.elements);
		var List<String> varNames = diffVarNames(oracle);
		var List<String> exprCombs = new ArrayList<String>();
		var List<Double> maxMinValueCombs = new ArrayList();
		var List<Double> minValues= getMinValues(varNames,list,listInfer);
		var List<Double> maxValues= getMaxValues(varNames,list,listInfer);
		exprCombs = generateCombinations(0, expresionWithVars, varNames, exprCombs, minValues,maxValues);
		for(String expression:exprCombs){
			maxMinValueCombs.add(evalExpression(expression));
		}
	
		return maxMinValueCombs;
	}
	def evalExpression(String expression) {
		var engine = new GraalJSEngineFactory().getScriptEngine();
		try {
			var obj = String.valueOf(engine.eval(expression));
			var ret= Double.valueOf(obj);
			return ret;
		} catch (ScriptException e) {
			e.printStackTrace();
			return null;
		}
	}
	def getMinValues(List<String> strings, EList<MonitoringPlan> list ,EList<MonitoringInferVariables> listInfer) {
		var List<Double> minValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						minValues.add(0.0);
					}
					else{
						minValues.add(plan.monitoringVariables.min.DVal);
					}
				}
			}
			if(listInfer!==null){
				for(MonitoringInferVariables variable: listInfer){
					if(variable.name.equals(name)){
						if(variable.monitoringVariableDatatype.sig_type.equals("boolean")){
							minValues.add(0.0);
						}
						else{
							minValues.add(variable.min.DVal);
						}
					}
				}
			}
		}
		return minValues;
	}
	
	def getMaxValues(List<String> strings, EList<MonitoringPlan> list,EList<MonitoringInferVariables> listInfer) {
		var List<Double> maxValues= new ArrayList();
		for(String name: strings){
			for(MonitoringPlan plan: list){
				if(plan.monitoringVariables.name.equals(name)){
					if(plan.monitoringVariables.monitoringVariableDatatype.sig_type.equals("boolean")){
						maxValues.add(1.0);
					}
					else{
						maxValues.add(plan.monitoringVariables.max.DVal);
					}
				}
			}if(listInfer!==null){
				for(MonitoringInferVariables variable: listInfer){
					if(variable.name.equals(name)){
						if(variable.monitoringVariableDatatype.sig_type.equals("boolean")){
							maxValues.add(0.0);
						}
						else{
							maxValues.add(variable.max.DVal);
						}
					}
				}
			}
		}
		return maxValues;
	}
	
	def List<String> generateCombinations(int index, String expression, List<String> varNames, List<String> exprCombs, List<Double> maxValues,List<Double> minValues) {
		var List<String> exC = new ArrayList<String>(exprCombs)
		var String replaceVarMin = replaceVar(expression, varNames.get(index),minValues.get(index));
		var String replaceVarMax = replaceVar(expression, varNames.get(index),maxValues.get(index));
		if (index == varNames.size() - 1) {
			exC.add(replaceVarMin);
			exC.add(replaceVarMax);
		} else {
			var List<String> minCombs = generateCombinations(index + 1, replaceVarMin, varNames, exprCombs,maxValues,minValues);
			var List<String> maxCombs = generateCombinations(index + 1, replaceVarMax, varNames, exprCombs,maxValues,minValues);
			exC.addAll(minCombs);
			exC.addAll(maxCombs);
		}
		return exC;
	}
	
	def replaceVar(String expression, String varName, Double value) {
		var String values="";
		if(value<0){
			values="("+Double.toString(value)+")";
		}
		else{
			values=Double.toString(value);
		}
		return expression.replace("@@" + varName + "@@", values);
	}
	
	def diffVarNames(Oracle oracle) {
		var List<String> varNames = new ArrayList<String>();
		for(AbstractElement2 name: oracle.check.em.elements)
		if(name.name!==null){
			varNames.add(name.name);
		}
		return varNames;
	}
	
	def getExpressionWithVars(EList<AbstractElement2> elements) {
		var String expression = "";
		for (AbstractElement2 element : elements) {
			if (element.getFrontParentheses().size() > 0) {
				for(var i=0; i<element.getFrontParentheses().size(); i++){
					expression += "(";
				}
				
			}
			if (element.getName() !== null) {
				expression += "@@" + element.getName() + "@@";
			}
			if (element.getValue() !== null) {
				if(element.getValue().getDVal()<0){
					expression += String.valueOf(element.getValue().getDVal());
				}
				else{
					expression += String.valueOf(element.getValue().getDVal());
				}
				
			}
			if (element.getOp() !== null) {
				for (Operators op : element.getOp()) {
					if (op.getOperator() !== null) {
						expression += op.getOperator().getOp().toString();
					} else if (op.getComparation() !== null) {
						expression += op.getComparation().getOp().toString();
					} else if (op.getLogicOperator() !== null) {
						expression += op.getLogicOperator().getOp().toString();
					} else if (op.getBackParentheses() !== null) {
						expression += op.getBackParentheses();
					}
				}
			}
		}
		return expression;
	}
	
	def appendFile(Signal s,String dotC, String dotVerdict) {
		var List<String> lineak= new ArrayList();
		var File myObj;
		var Scanner myReader;
		var String data;
		try {
	      myObj = new File(directory+dotC);
	      //println("Working Directory = " + System.getProperty("user.dir"));
	      myReader = new Scanner(myObj);
	      while (myReader.hasNextLine()) {
	        data = myReader.nextLine();
	        lineak.add(data);
	      }
	      myReader.close();
	    } catch (FileNotFoundException e) {
	      System.out.println("An error occurred.");
	      e.printStackTrace();
	    }
	    try {
	      myObj = new File(directory+dotVerdict);
	      myReader = new Scanner(myObj);
	      while (myReader.hasNextLine()) {
	        data = myReader.nextLine();
	        lineak.add(data);
	      }
	      myReader.close();
	    } catch (FileNotFoundException e) {
	      System.out.println("An error occurred.");
	      e.printStackTrace();
	    }
	    var FileWriter writer = new FileWriter(directory+dotC); 
		for(String str: lineak) {
		  writer.write(str + System.lineSeparator());
		}
		writer.close();
		
		
	}
	
	def CharSequence create_array_c(Signal s)'''
	#include "Array.h"
	void initArray(Array *a, size_t initialSize) {
		if (a->size == a->used) {
			a->array = malloc(initialSize * sizeof(double));
			a->used = 0;
			a->size = initialSize;
		}
	}
	
	void insertArray(Array *a, double element) {
		a->array[a->used++] = element;
		if (a->used == a->size) {
			a->size *= 2;
			a->array = realloc(a->array, a->size * sizeof(double));
		}
	
	}
	
	void freeArray(Array *a) {
		free(a->array);
		a->array = NULL;
		a->used = a->size = 0;
	}
	
	'''
	def create_global_h(Signal s)'''
	#ifndef «s.fullyQualifiedName.toUpperCase.toString»_H
	#define «s.fullyQualifiedName.toUpperCase.toString»_H
	#include <stdio.h>
	#include "Array.h"
	
	enum VerdictValue{
		VERDICT_PASSED,
		VERDICT_FAILED,
		VERDICT_INCONCLUSIVE,
		VERDICT_NONE,
		VERDICT_ERROR
	};
	enum VerdictType{
		VERDICTTYPE_CYCLE,
		VERDICTTYPE_PARTIAL,
		VERDICTTYPE_GLOBAL
	};
	typedef struct Verdict{
		enum VerdictValue verdict;
		double confidence;
		enum VerdictType type;
	}Verdict;
	typedef struct{
	«FOR plan: s.superType.monitoringPlan»
		«"\t"»double «plan.monitoringVariables.name»;
	«ENDFOR»	
	«"\t"»double timeStamp;
	}SensorInput, *SENSOR_INPUT;
	
	#endif
	
	'''
	def CharSequence create_array_h(Signal s)'''
	#ifndef ARRAY_H
	#define ARRAY_H
	#include <stdio.h>
	typedef struct {
		double *array;
		size_t used;
		size_t size;
	} Array;
	void initArray(Array *a, size_t initialSize);
	void insertArray(Array *a, double element);
	void freeArray(Array *a);
	
	#endif
	'''
	
//	def create_VP_json(ValidationPlan plan)'''
//	{
//	«"\t"»"tests" : {
//	«FOR test: plan.test»
//	«"\t\t"»"«test.name»" : {
//	«"\t\t\t"»"SUT": "«test.sut»" ,
//	«"\t\t\t"»"TestLevel": "«test.testLevel»" ,
//	«"\t\t\t"»"inputs": «FOR input : test.inputs» "«input.value»", «ENDFOR»
//	«"\t\t\t"»"oracles": {«FOR oracle: test.oracles»
//	«"\t\t\t\t"»"«oracle.name»" :{
//	«"\t\t\t\t\t"»"type": "«oracle.type»",
//	«"\t\t\t\t\t"»"prams": «FOR param: oracle.parameters»"«FOR param1: param.value.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»,"«ENDFOR»
//	«"\t\t\t\t"»},
//	«ENDFOR»
//	«"\t\t\t"»},
//	«"\t\t"»},
//	«ENDFOR»
//	«"\t"»}
//	}
//	'''
	
	def getAllNames(Signal signal) {
		var List<String> namelists;
		var List<String> whileNames;
		var List<String> whenNames;
		var List<String> checkNames;
		
		var Oracle oracle;
		var boolean is;
		for(var z=0; z< signal.oracle.size; z++){
			oracle=signal.oracle.get(z);
			namelists=new ArrayList();
			checkNames=new ArrayList();
			is=false;
			if(oracle.check.em!==null){
				for(var i=0; i< oracle.check.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(oracle.check.em.elements.get(i).name===null ||(namelists.get(j)!==null && namelists.get(j).equals(oracle.check.em.elements.get(i).name)) || oracle.check.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is && oracle.check.em.elements.get(i).name!==null){
						namelists.add(oracle.check.em.elements.get(i).name);
					}
					else{
						is=false;
					}
				}
			}
			else{
				namelists.add(oracle.check.name);
			}
			
			is=false;
			if(oracle.^while!==null){
				whileNames= new ArrayList();
				var wile=oracle.^while;
				var isWHile=false;
				for (var i=0; i<wile.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(wile.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(wile.em.elements.get(i).name);
						
					}
					else{
						is=false;
					}
					for(var j=0; j<whileNames.size;j++){
						if(wile.em.elements.get(i).name===null || (whileNames.get(j)!==null && whileNames.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							isWHile=true;
						}
					}
					if(!isWHile){
						whileNames.add(wile.em.elements.get(i).name);
						
					}
					else{
						isWHile=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whileNames.size; i++){
					if(i!=whileNames.size-1){
						a=a+"int "+whileNames.get(i)+", ";
						b=b+whileNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"int "+whileNames.get(i);
						b=b+whileNames.get(i)+".array[cycle] ";
					}
				}
				println(a);
				whileMap.put(oracle.name,a);
				whileMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.when!==null){
				whenNames= new ArrayList();
				var isWhen= false;
				var when=oracle.when;
				for (var i=0; i<when.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(when.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(when.em.elements.get(i).name);
					}
					else{
						is=false;
					}
					for(var j=0; j<whenNames.size;j++){
						if(when.em.elements.get(i).name===null || (whenNames.get(j)!==null && whenNames.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							isWhen=true;
						}
					}
					if(!isWhen){
						whenNames.add(when.em.elements.get(i).name);
					}
					else{
						isWhen=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whenNames.size; i++){
					if(i!=whenNames.size-1){
						a=a+"int "+whenNames.get(i)+", ";
						b=b+whenNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"int "+whenNames.get(i);
						b=b+whenNames.get(i)+".array[cycle]";
					}
				}
				whenMap.put(oracle.name,a);
				whenMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.check.reference!==null){
				if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
			
				else if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.upper!==null && oracle.check.reference.upper.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.upper.bound_upp.em.elements.size; i++){
						
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.same!==null && oracle.check.reference.same.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.same.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
							checkNames.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.notsame!==null && oracle.check.reference.notsame.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.notsame.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference!==null){
					if(oracle.check.reference.lower!==null && oracle.check.reference.lower.bound_lower.em!==null){
						for(var i=0; i<oracle.check.reference.lower.bound_lower.em.elements.size; i++){
							for(var j=0; j<namelists.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							namelists.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
							is=false;
							for(var j=0; j<checkNames.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							checkNames.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
						}
					}
				}
				
			}
			var namelists2= new ArrayList();
			for(var i=0; i<checkNames.size; i++){
				if(checkNames.get(i)!==null){
					namelists2.add(checkNames.get(i));
				}
			}	
			nameMap.put(oracle.name, namelists);
			checkVar.put(oracle.name,namelists2);
		}
	}
		
	
	//TODO ajustar paramteros necesarios
	def CharSequence create_oracle_json(Signal CPS)'''

	{ 
		"«CPS.name»":
		«"\t"»{
	    «"\t\t"»"inputVariationPoints": [
	    «FOR param1:CPS.superType.monitoringPlan»
	    «IF CPS.superType.monitoringPlan.indexOf(param1)!==CPS.superType.monitoringPlan.size-1»
	    «"\t\t\t"»{
	«"\t\t\t\t"»"name":"«param1.monitoringVariables.name»",
	«"\t\t\t\t"»"datatype": "«param1.monitoringVariables.monitoringVariableDatatype.sig_type»"
	«"\t\t\t"»}, 
		«ELSE»
	    «"\t\t\t"»{
	«"\t\t\t\t"»"name":"«param1.monitoringVariables.name»",
	«"\t\t\t\t"»"datatype": "«param1.monitoringVariables.monitoringVariableDatatype.sig_type»"
	«"\t\t\t"»} 
		«ENDIF»
	    «ENDFOR»
		«"\t\t"»],
		«IF CPS.superType.monitoringInferVariables.size!==0»
		«"\t\t"»"sinteticVariationPoints": [
		«FOR SV: CPS.superType.monitoringInferVariables»
		
		«IF CPS.superType.monitoringInferVariables.indexOf(SV)!==CPS.superType.monitoringInferVariables.size-1»
		«"\t\t\t"»{
		«"\t\t\t\t"»"name":"«SV.name»",
		«"\t\t\t\t"»"datatype":"«SV.monitoringVariableDatatype.sig_type»",
		«"\t\t\t\t"»"model":"«SV.model»"
		«"\t\t\t"»},
		«ENDIF»
		«ENDFOR»
		
		«"\t\t\t"»{
		«"\t\t\t\t"»"name":"«CPS.superType.monitoringInferVariables.get(CPS.superType.monitoringInferVariables.size-1).name»",
		«"\t\t\t\t"»"datatype":"«CPS.superType.monitoringInferVariables.get(CPS.superType.monitoringInferVariables.size-1).monitoringVariableDatatype»",
		«"\t\t\t\t"»"model":"«CPS.superType.monitoringInferVariables.get(CPS.superType.monitoringInferVariables.size-1).model»"
		«"\t\t\t"»}
		«"\t\t"»],
		«ENDIF»
		«"\t\t"»"evaluationFunctions": [
		«getOracleNames(CPS.oracle)»
		
		«"\t\t"»]
		«"\t"»}
	}
	'''
	
	def String getOracleNames(EList<Oracle> list) {
		var String ret="";
		for(var i=0; i<list.size; i++){
			ret=ret+"\t\t\t{\n\t\t\t\t\"name\": \""+list.get(i).name+"\"\n";
			if(i==list.size-1){
				ret=ret+"\t\t\t}\n";
			}
			else{
				ret=ret+"\t\t\t},\n";
			}
		}
		return ret;
	}
	
	

	//TODO division .h global(añadir verdict formato que esta en array.h) y .h por oraculo
	def create_oracle_h(Oracle param, List<String> nameList, String name)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	
	#include "oracle_commons.h"
	
	int preprocessInputs_«param.name»(SensorInput *inputs);
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs);
	Verdict performEvaluation_«param.name»(SensorInput *inputs);
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle);
	«IF param.check.reference.upper!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.lower!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.same!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.notsame!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.range!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR» double signal);
	«ELSEIF param.check.reference.gap!==null»
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ENDIF»
	#endif
	'''
	def create_C_oracle_h(CustomOracle param, String name)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	
	#include "oracle_commons.h"
	int preprocessInputs_«param.name»(SensorInput *inputs);
	«IF param.precondition!==null»
	int evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1» double «inputName», «ELSE»double «inputName» «ENDIF»«ENDFOR»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs);
	Verdict performEvaluation_«param.name»(SensorInput *inputs);
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle);
	double confCalculator_«param.name»(«FOR param1:param.checkInputs»double «param1.toString»,«ENDFOR»double signal);
	'''
	
	
	
	
	def create_verdict_c(Oracle param, List<String> nameList){
		verdict.add("Verdict checkGlobalVerdict_"+param.name+"(Array conf, Array timeStampOracle){");
		verdict.add("	Verdict verdict={VERDICT_INCONCLUISVE, 0.0, VERDICTTYPE_GLOBAL};");
		verdict.add("	double times;");
		verdict.add("	int fail, is, deg,i,time;");
		verdict.add("	i=0;");
		verdict.add("	while (i < conf.used && verdict.verdict==2) {");
		verdict.add("		if (conf.array[i] != 2) {");
		verdict.add("			verdict.verdict = VERDICT_PASSED;");
		verdict.add("		}");
		verdict.add("		i++;");
		verdict.add("	}");
		verdict.add("	if (verdict.verdict == 2) {");
		verdict.add("		return verdict;");
		verdict.add("	}");
		for(FailReason param1: param.check.failReason){
			if(param1.reason.highTime!==null){
				verdict.add("	fail =0;");
				verdict.add("	time=0;");
				verdict.add("	is=0;");
				verdict.add("	i=0;");
				verdict.add("	while(fail==0 && i<conf.used){");
				verdict.add("		if(conf.array[i]<"+param1.reason.highTime.cant.DVal+"){");
				verdict.add("			is==1;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("		time=i;");
				verdict.add("		while (is==1 && i<conf.used){");
				verdict.add("			if(conf.array[i]<"+param1.reason.highTime.cant.DVal+" && timeStampOracle.array[i] - timeStampOracle.array[time]>"+param1.reason.highTime.time.DVal+" || timeStampOracle.array[i] - timeStampOracle.array[time]>"+param1.reason.highTime.time.DVal+"){");
				verdict.add("				fail=1;");
				verdict.add("			}");
				verdict.add("			else{");
				verdict.add("				is=0;");
				verdict.add("			}");
				verdict.add("			i++;");
				verdict.add("		}");
				verdict.add("	}");
				verdict.add("	if(fail==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
								
			}	
			else if(param1.reason.highPeak!==null){
				verdict.add("	i=0;");
				verdict.add("	for(i=0; i< conf.used; i++){");
				verdict.add("		if(conf.array[i]<"+param1.reason.highPeak.cant.DVal+"){");
				verdict.add("			verdict.verdict=VERDICT_FAILED;");
				verdict.add("		}");
				verdict.add("	}");
			}
			else if(param1.reason.constDeg!==null){
				verdict.add("	deg=0;");
				verdict.add("	i=0;");
				verdict.add("	while(deg==0 && i<conf.length){");
				verdict.add("		if(conf.array[i]<"+param1.reason.constDeg.cant.DVal+"){");
				verdict.add("			deg=1;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	while(deg==1 && i<conf.used){");
				verdict.add("		if(conf.array[i]>"+param1.reason.constDeg.cant.DVal+"){");
				verdict.add("			deg=0;");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	if(i==conf.used && deg==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
	
				
			}
			else if(param1.reason.XPeaks!==null){
				verdict.add("	i=0;");
				verdict.add("	times="+param1.reason.XPeaks.NPeaks.DVal+";");
				verdict.add("	time=0;");
				verdict.add("	fail=0;");
				verdict.add("	while(i<conf.used && fail==0){")
				verdict.add("		if(conf.array[i]<"+param1.reason.XPeaks.cant.DVal+"»){");
				verdict.add("			if(time==0){");
				verdict.add("				time=i;");
				verdict.add("			}");
				verdict.add("			times--;");
				verdict.add("			if(times==0 && timeStampOracle.array[i] - timeStampOracle.array[time]<"+param1.reason.XPeaks.time.DVal+"»){");
				verdict.add("				fail=1;	");
				verdict.add("			}");
				verdict.add("			else if(times==0){");
				verdict.add("				times=0;");
				verdict.add("			}");
				verdict.add("		}");
				verdict.add("		i++;");
				verdict.add("	}");
				verdict.add("	if(fail==1){");
				verdict.add("		verdict.verdict=VERDICT_FAILED;	");
				verdict.add("	}");
			}	
		}
		verdict.add("	return verdict;");
		verdict.add("}");
	}

	def create_oracle_c(Oracle param,List<String> nameList)
	'''
	#include "«param.name.toString()».h"
			
	«IF param.check.description!==null»//«param.check.description.value»«ENDIF»
	
	int preprocessInputs_«param.name»(SensorInput *inputs) {
		//TODO.
	    return 1;
	}
	«IF param.when!==null || param.^while!==null»

	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF») {
		return «IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»;
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs){
	    Verdict verdict;
		//Step 1: inicializacion
	    static int cycle = -1;
		static Array timeStampOracle; 
	«FOR param1: nameMap.get(param.name)»
		static Array «param1»;
	«ENDFOR»
		static Array conf;
		static Array preconditionGiven;
	
		//Init arrays
		initArray(&conf,1);
		initArray(&preconditionGiven,1);
		initArray(&timeStampOracle,1);
	«FOR param1: nameMap.get(param.name)»
		initArray(&«param1» ,1);
	«ENDFOR»
		//Step 2: meter variables en array
		cycle++;
		insertArray(&timeStampOracle,inputs->timeStamp);
	«FOR param1: nameMap.get(param.name)»
	«"\t"»insertArray(&«param1»,inputs->«param1»);
	«ENDFOR»
	«IF param.when!==null || param.^while!==null»
	«"\t"»insertArray(&preconditionGiven,evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap_preconds.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap_preconds.get(param.name).toString»«ENDIF»));	
	«"\t"»if(preconditionGiven.array[cycle]==1){
		//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
	«"\t"»	insertArray(&conf,confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
	«"\t"»}else{
	«"\t"»	insertArray(&conf,2);
	«"\t"»}
	«ELSE»
	«"\t"»insertArray(&preconditionGiven,2);
	«"\t"»insertArray(&conf,confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
	«ENDIF»

		//Step 4: Sacar confidence

		verdict = checkGlobalVerdict_«param.name»(conf, timeStampOracle); 
		verdict.confidence=conf.array[cycle];
		
	    return verdict;
	}
		
	double confCalculator_«param.name»(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal){
		double conf=0;
		«confCalculationBody»
		«IF param.check.reference.gap!==null»
		if(signal<«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal>«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal<«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.gap.bound_lower.value!==null»«IF param.check.reference.gap.bound_lower.value.DVal>=0»«param.check.reference.gap.bound_lower.value.DVal»«ELSE»(«param.check.reference.gap.bound_lower.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF minMap.get(param.name)<0»(«minMap.get(param.name)») «ELSE»«minMap.get(param.name)»«ENDIF»);
		}
		else if(signal>«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«maxMap.get(param.name)»-«IF param.check.reference.gap.bound_upp.value!==null»«IF param.check.reference.gap.bound_upp.value.DVal>=0»«param.check.reference.gap.bound_upp.value.DVal»«ELSE»(«param.check.reference.gap.bound_upp.value.DVal»)«ENDIF»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSEIF param1.value!==null»«IF param1.value.DVal>=0»«param1.value.DVal»«ELSE»(«param1.value.DVal»)«ENDIF»«ELSE»«IF param1.math.library.cos!==null»calcCos«ELSEIF param1.math.library.sin!==null»calcSin«ELSEIF param1.math.library.derivative!==null»calcDerivative«ELSE»calcModulus«ENDIF»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		«ENDIF»
		return conf;
	}
	«FOR String a:verdict»
	«a»
	«ENDFOR»
	
	'''
	def create_C_oracle_c(CustomOracle param)'''
	#include "«param.name.toString()».h"
				
	«IF param.description!==null»//«param.description»«ENDIF»
	
	int preprocessInputs_«param.name»(SensorInput *inputs) {
			//TODO.
		    return 1;
	}
	«IF param.precondition!==null»
	int evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1» double «inputName», «ELSE»double «inputName» «ENDIF»«ENDFOR»);
		//TODO
		return
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs){
	    Verdict verdict;
		//Step 1: inicializacion
	    static int cycle = -1;
		static Array timeStampOracle;
	«FOR param1: predAndCheckInputs»
	«"\t"»static Array «param1»;
	«ENDFOR»

		static Array conf;
		static Array preconditionGiven;
	
		//Init arrays
		initArray(&conf,1);
		initArray(&preconditionGiven,1);
		initArray(&timeStampOracle,1);
	«FOR param1: predAndCheckInputs»
	«"\t"»initArray(&«param1» ,1);
	«ENDFOR»
		//Step 2: meter variables en array
		cycle++;
		insertArray(&timeStampOracle,inputs->timeStamp);
	«FOR param1: predAndCheckInputs»
	«"\t"»insertArray(&«param1»,inputs->«param1»);
	«ENDFOR»

	«IF param.precondition!==null»
	«"\t"»insertArray(&preconditionGiven,evaluatePreConditions_«param.name»(«FOR inputName:param.predInputs»«IF param.predInputs.indexOf(inputName)<param.predInputs.size()-1»«inputName», «ELSE»«inputName» «ENDIF»«ENDFOR»);	
	«"\t"»if(preconditionGiven.array[cycle]==1){
	«"\t"»//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
	«"\t\t"»insertArray(&conf,confCalculator_«param.name»(«FOR inputName:param.checkInputs»«IF param.checkInputs.indexOf(inputName)<param.checkInputs.size()-1»«inputName».array[cycle], «ELSE»«inputName».array[cycle] «ENDIF»«ENDFOR»);
	«"\t"»}else{
	«"\t\t"»insertArray(&conf,2);
	«"\t"»}
	«ELSE»
	«"\t"»insertArray(&preconditionGiven,2);
	«"\t"»insertArray(&conf,confCalculator_«param.name»(«FOR inputName:param.checkInputs»«IF param.checkInputs.indexOf(inputName)<param.checkInputs.size()-1»«inputName».array[cycle], «ELSE»«inputName».array[cycle] «ENDIF»«ENDFOR»);
	«ENDIF»
	//Step 4: Sacar confidence
	
		verdict = checkGlobalVerdict_«param.name»(conf, timeStampOracle); 
		verdict.confidence=conf.array[cycle];
		
	    return verdict;
	}
	double confCalculator_«param.name»(«FOR param1:param.checkInputs»double «param1.toString»,«ENDFOR»double signal){
		double conf=0;
		
		//TODO
		
		return conf;
	}
	Verdict checkGlobalVerdict_«param.name»(Array conf, Array timeStampOracle){
		verdict.verdict=VERDICT_INCONCLUSIVE;
	}	
	'''
}


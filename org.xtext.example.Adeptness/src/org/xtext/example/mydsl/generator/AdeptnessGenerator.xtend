/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import com.google.inject.Inject
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.example.mydsl.adeptness.Oracle
import org.xtext.example.mydsl.adeptness.Signal
import org.xtext.example.mydsl.adeptness.ValidationPlan

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AdeptnessGenerator extends AbstractGenerator {
 @Inject extension IQualifiedNameProvider

	//Poner el directorio de la seinal, donde se van a generar los .c y .h para poder compilarlo en matlab y generar el .mex file
	//String directory="C:\\Users\\hazibek02\\runtime-EclipseXtext\\Matlab\\src-gen\\lehenengoa\\"; 
var HashMap<String, List<String>> nameMap;
var HashMap<String, String> whenMap;
var HashMap<String, String> whileMap;
var HashMap<String, String> whenMap_preconds;
var HashMap<String, String> whileMap_preconds;
var HashMap<String, List<String>> checkVar;
    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    	//fsa.generateFile("adeptness.xml", resource.allContents.toIterable.filter(Signal).createXML());
    		for(a: resource.allContents.toIterable.filter(ValidationPlan)){
    			fsa.generateFile(a.fullyQualifiedName.toString("/")+".json", a.create_VP_json())
    		}
      		for(e: resource.allContents.toIterable.filter(Signal)){
       	
			/*for(f: e.check_range){
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".c", f.create_range_c())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".h", f.create_range_h())
				fsa.generateFile(f.fullyQualifiedName.toString("/")+".m", f.create_range_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+f.name.toString+"')");
			}
			for (u: e.check_gap){
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".c", u.create_gap_c())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".h", u.create_gap_h())
				fsa.generateFile(u.fullyQualifiedName.toString("/")+".m", u.create_gap_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+u.name.toString+"')");
			}
			for(l: e.check_static_lower){
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".c", l.create_low_c())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".h", l.create_low_h())
				fsa.generateFile(l.fullyQualifiedName.toString("/")+".m", l.create_low_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+l.name.toString+"')");
			}
			for(d: e.check_static_upper){
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".c", d.create_up_c())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".h", d.create_up_h())
				fsa.generateFile(d.fullyQualifiedName.toString("/")+".m", d.create_up_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}*/
			nameMap= new HashMap();
			whenMap=new HashMap();
			whileMap= new HashMap();
			whileMap_preconds= new HashMap();
			whenMap_preconds= new HashMap();
			checkVar= new HashMap();
			getAllNames(e);
			for(q: e.oracle){
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".c", q.create_oracle_c(nameMap.get(q.name)))
				fsa.generateFile(q.fullyQualifiedName.toString("/")+".h", q.create_oracle_h(nameMap.get(q.name)))
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".json", q.create_oracle_json())
				//fsa.generateFile(q.fullyQualifiedName.toString("/")+".m", q.create_oracle_m())
				//Runtime.getRuntime().exec("matlab -nosplash -nodesktop -r run('"+directory+d.name.toString+"')");
			}
			fsa.generateFile(e.fullyQualifiedName.toString("/")+".json", e.create_oracle_json())
			
		}
    }
	
	def create_VP_json(ValidationPlan plan)'''
	{
	«"\t"»"tests" : {
	«FOR test: plan.test»
	«"\t\t"»"«test.name»" : {
	«"\t\t\t"»"SUT": "«test.sut»" ,
	«"\t\t\t"»"TestLevel": "«test.testLevel»" ,
	«"\t\t\t"»"inputs": «FOR input : test.inputs» "«input.value»", «ENDFOR»
	«"\t\t\t"»"oracles": {«FOR oracle: test.oracles»
	«"\t\t\t\t"»"«oracle.name»" :{
	«"\t\t\t\t\t"»"type": "«oracle.type»",
	«"\t\t\t\t\t"»"prams": «FOR param: oracle.parameters»"«FOR param1: param.value.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»,"«ENDFOR»
	«"\t\t\t\t"»},
	«ENDFOR»
	«"\t\t\t"»},
	«"\t\t"»},
	«ENDFOR»
	«"\t"»}
	}
	'''
	
	def getAllNames(Signal signal) {
		var List<String> namelists;
		var List<String> whileNames;
		var List<String> whenNames;
		var List<String> checkNames;
		
		var Oracle oracle;
		var boolean is;
		for(var z=0; z< signal.oracle.size; z++){
			oracle=signal.oracle.get(z);
			namelists=new ArrayList();
			checkNames=new ArrayList();
			is=false;
			if(oracle.check.em!==null){
				for(var i=0; i< oracle.check.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(oracle.check.em.elements.get(i).name===null ||(namelists.get(j)!==null && namelists.get(j).equals(oracle.check.em.elements.get(i).name)) || oracle.check.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is && oracle.check.em.elements.get(i).name!==null){
						namelists.add(oracle.check.em.elements.get(i).name);
					}
					else{
						is=false;
					}
				}
			}
			else{
				namelists.add(oracle.check.name);
			}
			
			is=false;
			if(oracle.^while!==null){
				whileNames= new ArrayList();
				var wile=oracle.^while;
				var isWHile=false;
				for (var i=0; i<wile.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(wile.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(wile.em.elements.get(i).name);
						
					}
					else{
						is=false;
					}
					for(var j=0; j<whileNames.size;j++){
						if(wile.em.elements.get(i).name===null || (whileNames.get(j)!==null && whileNames.get(j).equals(wile.em.elements.get(i).name)) || wile.em.elements.get(i).name.equals("timeStamp")){
							isWHile=true;
						}
					}
					if(!isWHile){
						whileNames.add(wile.em.elements.get(i).name);
						
					}
					else{
						isWHile=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whileNames.size; i++){
					if(i!=whileNames.size-1){
						a=a+"int "+whileNames.get(i)+", ";
						b=b+whileNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"int "+whileNames.get(i);
						b=b+whileNames.get(i)+".array[cycle] ";
					}
				}
				println(a);
				whileMap.put(oracle.name,a);
				whileMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.when!==null){
				whenNames= new ArrayList();
				var isWhen= false;
				var when=oracle.when;
				for (var i=0; i<when.em.elements.size; i++){
					for(var j=0; j<namelists.size;j++){
						if(when.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							is=true;
						}
					}
					if(!is){
						namelists.add(when.em.elements.get(i).name);
					}
					else{
						is=false;
					}
					for(var j=0; j<whenNames.size;j++){
						if(when.em.elements.get(i).name===null || (whenNames.get(j)!==null && whenNames.get(j).equals(when.em.elements.get(i).name)) || when.em.elements.get(i).name.equals("timeStamp")){
							isWhen=true;
						}
					}
					if(!isWhen){
						whenNames.add(when.em.elements.get(i).name);
					}
					else{
						isWhen=false;
					}
				}
				var a="";
				var b="";
				for(var i=0; i< whenNames.size; i++){
					if(i!=whenNames.size-1){
						a=a+"int "+whenNames.get(i)+", ";
						b=b+whenNames.get(i)+".array[cycle], ";
					}
					else{
						a=a+"int "+whenNames.get(i);
						b=b+whenNames.get(i)+".array[cycle]";
					}
				}
				whenMap.put(oracle.name,a);
				whenMap_preconds.put(oracle.name,b);
			}
			is=false;
			if(oracle.check.reference!==null){
				if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_lower.em.elements.get(i).name)) || oracle.check.reference.gap.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
			
				else if(oracle.check.reference.gap!==null && oracle.check.reference.gap.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.gap.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.gap.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.gap.bound_upp.em.elements.get(i).name)) || oracle.check.reference.gap.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.gap.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_lower.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_lower.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_lower.em.elements.get(i).name)) || oracle.check.reference.range.bound_lower.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_lower.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.range!==null && oracle.check.reference.range.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.range.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.range.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.range.bound_upp.em.elements.get(i).name)) || oracle.check.reference.range.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.range.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.upper!==null && oracle.check.reference.upper.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.upper.bound_upp.em.elements.size; i++){
						
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.upper.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.upper.bound_upp.em.elements.get(i).name)) || oracle.check.reference.upper.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.upper.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.same!==null && oracle.check.reference.same.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.same.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false;
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.same.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.same.bound_upp.em.elements.get(i).name)) || oracle.check.reference.same.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.same.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference.notsame!==null && oracle.check.reference.notsame.bound_upp.em!==null){
					for(var i=0; i<oracle.check.reference.notsame.bound_upp.em.elements.size; i++){
						for(var j=0; j<namelists.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						namelists.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
						is=false
						for(var j=0; j<checkNames.size;j++){
							if(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name)) || oracle.check.reference.notsame.bound_upp.em.elements.get(i).name.equals("timeStamp")){
								is=true;
							}
						}
						if(!is){
						checkNames.add(oracle.check.reference.notsame.bound_upp.em.elements.get(i).name);
						}
						else{
							is=false;
						}
					}
				}
				else if(oracle.check.reference!==null){
					if(oracle.check.reference.lower!==null && oracle.check.reference.lower.bound_lower.em!==null){
						for(var i=0; i<oracle.check.reference.lower.bound_lower.em.elements.size; i++){
							for(var j=0; j<namelists.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (namelists.get(j)!==null && namelists.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							namelists.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
							is=false;
							for(var j=0; j<checkNames.size;j++){
								if(oracle.check.reference.lower.bound_lower.em.elements.get(i).name===null || (checkNames.get(j)!==null && checkNames.get(j).equals(oracle.check.reference.lower.bound_lower.em.elements.get(i).name)) || oracle.check.reference.lower.bound_lower.em.elements.get(i).name.equals("timeStamp")){
									is=true;
								}
							}
							if(!is){
							checkNames.add(oracle.check.reference.lower.bound_lower.em.elements.get(i).name);
							}
							else{
								is=false;
							}
						}
					}
				}
				
			}
				
			nameMap.put(oracle.name, namelists);
			checkVar.put(oracle.name,checkNames);
		}
	}
		
	/*def createXML(Iterable<Signal> signals)'''
	<?xml version='1.0' encoding="UTF-8"?>
		«FOR s : signals»
			<Signal>
				<SignalDescription name="«s.fullyQualifiedName.toString("/")»">
					<TypeSignalDescription name="Static">
						«FOR c: s.check_gap»
							<Type name="«c.name.toString»">
								<Parameters>
									<«c.inclusive_bound.eClass.name.toString()»>«c.inclusive_bound.value.bool»</«c.inclusive_bound.eClass.name.toString()»>
									<«c.bound_up.eClass.name.toString()»>«c.bound_up.value.DVal»</«c.bound_up.eClass.name.toString()»>
									<«c.bound_low.eClass.name.toString()»>«c.bound_low.value.DVal»</«c.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Low">
						«FOR l: s.check_static_lower»
							<Type name="«l.name.toString»">
								<Parameters>
									<«l.inclusive_bound.eClass.name.toString()»>«l.inclusive_bound.value.bool»</«l.inclusive_bound.eClass.name.toString()»>
									<«l.bound_low.eClass.name.toString()»>«l.bound_low.value.DVal»</«l.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Static_Up">
						«FOR u: s.check_static_upper»
							<Type name="«u.name.toString»">
								<Parameters>
									<«u.inclusive_bound.eClass.name.toString()»>«u.inclusive_bound.value.bool»</«u.inclusive_bound.eClass.name.toString()»>
									<«u.bound_up.eClass.name.toString()»>«u.bound_up.value.DVal»</«u.bound_up.eClass.name.toString()»>
								</Parameters>
							</Type>				
						«ENDFOR»
					</TypeSignalDescription>
					<TypeSignalDescription name="Dynamic">
						«FOR d: s.check_range»
							<Type name="«d.name.toString»">
								<Parameters>
									<«d.inclusive_bound.eClass.name.toString()»>«d.inclusive_bound.value.bool»</«d.inclusive_bound.eClass.name.toString()»>
									<«d.bound_up.eClass.name.toString()»>«d.bound_up.value.DVal»</«d.bound_up.eClass.name.toString()»>
									<«d.bound_low.eClass.name.toString()»>«d.bound_low.value.DVal»</«d.bound_low.eClass.name.toString()»>
								</Parameters>
							</Type>		
						«ENDFOR»
					</TypeSignalDescription>						
				</SignalDescription>
			</Signal>
		«ENDFOR»
	'''*/
	
	
	/*def create_oracle_m(Oracle param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''*/
	//Expresions in values check
	def CharSequence create_oracle_json(Signal CPS)'''
	«var cont=0»
	{
		"Name":"«CPS.name»",
	«FOR param: CPS.oracle»
			"«param.name»":{
				"cfileDirectory":"«param.fullyQualifiedName.toString("/")+".c"»",
				"hfileDirectory":"«param.fullyQualifiedName.toString("/")+".h"»",
				«"\t\t"»"Inputs":[«FOR name:nameMap.get(param.name)»"«name»", «ENDFOR»"timeStamp"],
			«"\t"»"While":"«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»",«ELSE»null",«ENDIF»
			«"\t"»"When":{
				«"\t"»"Value":"«IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»",«ELSE»null",«ENDIF»
				«"\t"»"AfterWhen":{
				«IF param.when!==null»
					«IF param.when.aw!==null»
						«IF param.when.aw.during!==null»
					«"\t"»"Type":"During",
					«"\t"»"Value":"«param.when.aw.during.time.DVal»",
					«"\t"»"Unit":"«param.when.aw.during.unit.time»"
						«ELSEIF param.when.aw.getWait!==null»
					«"\t"»"Type":"Wait",
					«"\t"»"Value":"«param.when.aw.getWait.time.DVal»",
					«"\t"»"Unit":"«param.when.aw.getWait.unit.time»"
						«ENDIF»
					«ELSE»
					«"\t"»"Type":"null",
					«"\t"»"Value":"null",
					«"\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t"»"Type":"null",
					«"\t"»"Value":"null",
					«"\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t"»},
		«IF param.check.name!==null»
			«"\t\t"»"Check":"«param.check.name» ",
		«ELSE»
			«"\t\t"»"Check":" «FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»",
		«ENDIF»
		«IF param.check.reference.lower!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Above",
				«"\t\t"»"Value":["«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»"],«ELSE»«FOR param1: param.check.reference.lower.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.lower.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.lower.exactly.value.DVal»",
					«IF param.check.reference.lower.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.exactly.unit.time»"
					«ELSE»
							«"\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.lower.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.lower.atleast.value.DVal»",
					«IF param.check.reference.lower.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.lower.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.lower.atmost.value.DVal»",
					«IF param.check.reference.lower.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.lower.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.lower.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.upper!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Below",
				«"\t\t"»"Value":["«IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.upper.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.upper.exactly!==null»
				«"\t\t\t"»	"Type":"exactly",
				«"\t\t\t"»	"Value":"«param.check.reference.upper.exactly.value.DVal»",
					«IF param.check.reference.upper.exactly.time!==null»
						«"\t\t\t"»	"Time":"«param.check.reference.upper.exactly.time.DVal»",
						«"\t\t\t"»	"Unit":"«param.check.reference.upper.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.upper.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.upper.atleast.value.DVal»",
					«IF param.check.reference.upper.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.upper.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.upper.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.upper.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.upper.atmost.value.DVal»",
					«IF param.check.reference.upper.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.upper.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.upper.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.range!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Range",
				«"\t\t"»"Value":["«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»",«ELSE»«FOR param1: param.check.reference.range.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.range.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.range.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.range.exactly.value.DVal»",
					«IF param.check.reference.range.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.range.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.range.atleast.value.DVal»",
					«IF param.check.reference.range.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.range.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.range.atmost.value.DVal»",
					«IF param.check.reference.range.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.range.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.range.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.gap!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Gap",
				«"\t\t"»"Value":["«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»",«ELSE»«FOR param1: param.check.reference.gap.bound_lower.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value»"],«ELSE»«FOR param1: param.check.reference.gap.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.gap.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.gap.exactly.value.DVal»",
					«IF param.check.reference.gap.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.gap.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.gap.atleast.value.DVal»",
					«IF param.check.reference.gap.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.gap.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.gap.atmost.value.DVal»",
					«IF param.check.reference.gap.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.gap.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.gap.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.same!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"Same",
				«"\t\t"»"Value":["«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.same.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»"],«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.same.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.same.exactly.value.DVal»",
					«IF param.check.reference.same.exactly.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.exactly.unit.time»"
					«ELSE»
							«"\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.same.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.same.atleast.value.DVal»",
					«IF param.check.reference.same.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.same.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.same.atmost.value.DVal»",
					«IF param.check.reference.same.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.same.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.same.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ELSEIF param.check.reference.notsame!==null»
			«"\t\t"»"Reference":{
				«"\t\t"»"Type":"NotSame",
				«"\t\t"»"Value":["«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»"],«ELSE»«FOR param1: param.check.reference.notsame.bound_upp.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR» «ENDFOR»",«ENDIF»
				«"\t\t"»"Trace":{
				«IF param.check.reference.notsame.exactly!==null»
					«"\t\t\t"»"Type":"exactly",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.exactly.value.DVal»"
					«IF param.check.reference.notsame.exactly.time!==null»
						«"\t\t\t"»	"Time":"«param.check.reference.notsame.exactly.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.exactly.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.notsame.atleast!==null»
					«"\t\t\t"»"Type":"atLeast",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.atleast.value.DVal»"
					«IF param.check.reference.notsame.atleast.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.notsame.atleast.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.atleast.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSEIF param.check.reference.notsame.atmost!==null»
					«"\t\t\t"»"Type":"atMost",
					«"\t\t\t"»"Value":"«param.check.reference.notsame.atmost.value.DVal»"
					«IF param.check.reference.notsame.atmost.time!==null»
							«"\t\t\t"»"Time":"«param.check.reference.notsame.atmost.time.DVal»",
							«"\t\t\t"»"Unit":"«param.check.reference.notsame.atmost.unit.time»"
					«ELSE»
							«"\t\t\t"»"Time":"null",
							«"\t\t\t"»"Unit":"null"
					«ENDIF»
				«ELSE»
					«"\t\t\t"»"Type":"null",
					«"\t\t\t"»"Time":"null",			
					«"\t\t\t"»"Unit":"null"
				«ENDIF»
				«"\t\t"»}
			«"\t\t"»},
		«ENDIF»
		«FOR failreason: param.check.failReason»
			«"\t\t"»"FailReason":{
		«IF failreason.reason.highPeak!==null»
				«"\t"»"Type":"HighPeak",
				«"\t"»"Cant":"«failreason.reason.highPeak.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"null",
				«"\t"»"Unit":"null"
		«ELSEIF failreason.reason.highTime!==null»
				«"\t"»"Type":"HighTime",
				«"\t"»"Cant":"«failreason.reason.highTime.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"«failreason.reason.highTime.time.DVal»",
				«"\t"»"Unit":"«failreason.reason.highTime.unit.time»"
		«ELSEIF failreason.reason.XPeaks!==null»
				«"\t"»"Type":"XPeaks",
				«"\t"»"Cant":"«failreason.reason.XPeaks.cant.DVal»",
				«"\t"»"NPeaks":"«failreason.reason.XPeaks.NPeaks.DVal»",
				«"\t"»"Time":"«failreason.reason.XPeaks.time.DVal»",
				«"\t"»"Unit":"«failreason.reason.XPeaks.unit.time»"
		«ELSEIF failreason.reason.constDeg!==null»
				«"\t"»"Type":"ConstantDegradation",
				«"\t"»"Cant":"«failreason.reason.constDeg.cant.DVal»",
				«"\t"»"NPeaks":"null",
				«"\t"»"Time":"null",
				«"\t"»"Unit":"null"
		«ENDIF»
			«"\t\t"»},
		«ENDFOR»
			«"\t"»"Description":"«param.check.description.value»"
		«IF (cont++)!=CPS.oracle.size-1»
			«"\t"»},
		«ELSE»
			«"\t"»}
		«ENDIF»
	«ENDFOR»
	}
	
	'''
	def create_oracle_h(Oracle param, List<String> nameList)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	#include <stdio.h>
	typedef struct{
		int verdict;
		double confidence;
	}Verdict;
	typedef struct{
		«FOR param1: nameMap.get(param.name)»
		double «param1»;
		«ENDFOR»
	}SensorInput, *SENSOR_INPUT;
	typedef struct {
	  double *array;
	  size_t used;
	  size_t size;
	} Array;
	void initArray(Array *a, size_t initialSize);
	void insertArray(Array *a, double element);
	void freeArray(Array *a);
	int preprocessInputs(SensorInput *inputs, int inputQty);
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF»);
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs, int inputQty);
	Verdict performEvaluation_«param.name»(SensorInput *inputs, int inputQty, double timeStamp);
	Verdict checkGlobalVerdict(Array conf, Array timeStampOracle);
	«IF param.check.reference.upper!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.lower!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.same!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.notsame!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ELSEIF param.check.reference.range!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR» double signal);
	«ELSEIF param.check.reference.gap!==null»
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal);
	«ENDIF»
	#endif
	'''
	
	def create_oracle_c(Oracle param,List<String> nameList)
	'''
	#include "«param.name.toString()».h"
	#define VERDICT_PASSED 1;
	#define VERDICT_FAILED 0;
	#define VERDICT_INCONCLUSIVE 2;
	//«param.check.description.value»
	
	int preprocessInputs(SensorInput *inputs, int inputQty) {
		//TODO.
	    return inputQty;
	}
	«IF param.when!==null || param.^while!==null»
	int evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap.get(param.name).toString»«ENDIF») {
		return «IF param.when!==null»«FOR param1: param.when.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»«IF param.^while!==null»«FOR param1: param.^while.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF» «FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op» «ELSEIF parent.logicOperator!==null»«parent.logicOperator.op» «ELSEIF parent.operator!==null»«parent.operator.op» «ENDIF»«ENDFOR»«ENDFOR»«ENDIF»;
	}
	«ENDIF»
	Verdict evaluatePostConditions_«param.name»(Verdict verdict, SensorInput *inputs, int inputQty) {
	    verdict.verdict = VERDICT_PASSED;
	    verdict.confidence = 1;
	    return verdict;
	}
	Verdict performEvaluation_«param.name»(SensorInput *inputs, int inputQty, double timeStamp){
	    Verdict verdict;
		//Step 1: inicializacion
	    static int cycle = -1;
		static Array timeStampOracle; 
		«FOR param1: nameMap.get(param.name)»
		static Array «param1»;
		«ENDFOR»
		static Array conf;
		static Array preconditionGiven;
	
		//Init arrays
		initArray(&conf,1);
		initArray(&preconditionGiven,1);
		initArray(&timeStampOracle,1);
		«FOR param1: nameMap.get(param.name)»
		initArray(&«param1» ,1);
		«ENDFOR»
		//Step 2: meter variables en array
		cycle++;
		insertArray(&timeStampOracle,timeStamp);
		«FOR param1: nameMap.get(param.name)»
		insertArray(&«param1»,inputs->«param1»);
		«ENDFOR»
		«IF param.when!==null || param.^while!==null»
		insertArray(&preconditionGiven,evaluatePreConditions_«param.name»(«IF param.when!==null»«whenMap_preconds.get(param.name).toString»«ELSEIF param.^while!==null»«whileMap_preconds.get(param.name).toString»«ENDIF»));	
		if(preconditionGiven.array[cycle]==1){
		//Step 3: Sacar confidence. Si se da la precondicion (when: (Elevator1DoorStatus==1 && Elevator1DoorSensor == 1))
			insertArray(&conf,confCalculator(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
		}else{
			insertArray(&conf,2);
		}
		«ELSE»
		insertArray(&preconditionGiven,2);
		insertArray(&conf,confCalculator(«FOR param1:checkVar.get(param.name)»«param1.toString».array[cycle], «ENDFOR»«IF param.check.name!==null»«param.check.name».array[cycle] «ELSE»«FOR param1: param.check.em.elements»«FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR» «ENDFOR»«ENDIF»));
		«ENDIF»

		//Step 4: Sacar confidence

		verdict = checkGlobalVerdict(conf, timeStampOracle); 
		verdict.confidence=conf.array[cycle];
		
	    return verdict;
	}
	
	double confCalculator(«FOR param1:checkVar.get(param.name)»double «param1.toString»,«ENDFOR»double signal){
		double conf=0;
		«IF param.check.reference.upper!==null»
		if(signal<«IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf= («IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		else(){
			conf= («IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(99999-«IF param.check.reference.upper.bound_upp.value!==null»«param.check.reference.upper.bound_upp.value.DVal»«ELSEIF param.check.reference.upper.bound_upp.em.elements!==null»«FOR param1:param.check.reference.upper.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		«ELSEIF param.check.reference.lower!==null»
		if(signal>«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
				
			conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(9999-«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		else(){
			conf=(signal-«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.lower.bound_lower.value!==null»«param.check.reference.lower.bound_lower.value.DVal»«ELSEIF param.check.reference.lower.bound_lower.em.elements!==null»«FOR param1:param.check.reference.lower.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		«ELSEIF param.check.reference.same!==null»
		if(signal==«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=1;
		}
		else if(signal<«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		else if(signal>«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(9999-«IF param.check.reference.same.bound_upp.value!==null»«param.check.reference.same.bound_upp.value.DVal»«ELSEIF param.check.reference.same.bound_upp.em.elements!==null»«FOR param1:param.check.reference.same.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		«ELSEIF param.check.reference.notsame!==null»
		if(signal==«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=-1;
		}
		else if(signal<«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		else if(signal>«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.notsame.bound_upp.value!==null»«param.check.reference.notsame.bound_upp.value.DVal»«ELSEIF param.check.reference.notsame.bound_upp.em.elements!==null»«FOR param1:param.check.reference.notsame.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-99999);
		}
		«ELSEIF param.check.reference.range!==null»
		if(signal<«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal>«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal<«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(«IF param.check.reference.range.bound_lower.value!==null»«param.check.reference.range.bound_lower.value.DVal»«ELSEIF param.check.reference.range.bound_lower.em.elements!==null»«FOR param1:param.check.reference.range.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		else if(signal>«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(9999-«IF param.check.reference.range.bound_upp.value!==null»«param.check.reference.range.bound_upp.value.DVal»«ELSEIF param.check.reference.range.bound_upp.em.elements!==null»«FOR param1:param.check.reference.range.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		«ELSEIF param.check.reference.gap!==null»
		if(signal<«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal>«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/((«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal>«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» && signal<«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF» + («IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/((«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/2);
		}
		else if(signal<«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-signal)/(«IF param.check.reference.gap.bound_lower.value!==null»«param.check.reference.gap.bound_lower.value.DVal»«ELSEIF param.check.reference.gap.bound_lower.em.elements!==null»«FOR param1:param.check.reference.gap.bound_lower.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»-(-99999));
		}
		else if(signal>«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»){
			conf=(signal-«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name»«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»)/(9999-«IF param.check.reference.gap.bound_upp.value!==null»«param.check.reference.gap.bound_upp.value.DVal»«ELSEIF param.check.reference.gap.bound_upp.em.elements!==null»«FOR param1:param.check.reference.gap.bound_upp.em.elements» «FOR parent: param1.frontParentheses»( «ENDFOR»«IF param1.name!==null»«param1.name».array[cycle]«ELSE»«param1.value.DVal»«ENDIF»«FOR parent:param1.op»«IF parent.backParentheses!==null») «ELSEIF parent.comparation!==null»«parent.comparation.op»«ELSEIF parent.logicOperator!==null»«parent.logicOperator.op»«ELSEIF parent.operator!==null»«parent.operator.op»«ENDIF»«ENDFOR»«ENDFOR»«ENDIF»);
		}
		«ENDIF»
		return conf;
	}
	Verdict checkGlobalVerdict(Array conf, Array timeStampOracle){
		Verdict verdict;
		verdict.verdict=VERDICT_INCONCLUSIVE;
		double times;
		int fail, is, deg,i,time;
		i=0;
		while (i < conf.used && verdict.verdict==2) {
			if (conf.array[i] != 2) {
				verdict.verdict = VERDICT_PASSED;
			}
			i++;
		}
		if (verdict.verdict == 2) {
			return verdict;
		}
		«FOR param1: param.check.failReason» 
		«IF param1.reason.highTime!==null»
		fail =0;
		time=0;
		is=0;
		i=0;
		while(fail==0 && i<conf.used){
			if(conf.array[i]<«param1.reason.highTime.cant.DVal»){
				is==1;
			}
			i++;
			time=i;
			while (is==1 && i<conf.used){
				if(conf.array[i]<«param1.reason.highTime.cant.DVal» && timeStampOracle.array[i] - timeStampOracle.array[time]>«param1.reason.highTime.time.DVal» || timeStampOracle.array[i] - timeStampOracle.array[time]>«param1.reason.highTime.time.DVal»){
					fail=1;
				}
				else{
					is=0;
				}
				i++;
			}
		}
		if(fail==1){
			verdict.verdict=VERDICT_FAILED;	
		}
		
		«ELSEIF param1.reason.highPeak!==null»
		i=0;
		for(i=0; i< conf.used; i++){
			if(conf.array[i]< «param1.reason.highPeak.cant.DVal»){
				verdict.verdict=VERDICT_FAILED;
			}
		}
		
		«ELSEIF param1.reason.constDeg!==null»
		deg=0;
		i=0;
		while(deg==0 && i<conf.length){
			if(conf.array[i]< «param1.reason.constDeg.cant.DVal»){
				deg=1;
			}
			i++
		}				
		while(deg==1 && i<conf.used){
			if(conf.array[i]>«param1.reason.constDeg.cant.DVal»){
				deg=0;
			}
			i++;
		}
		if(i==conf.used && deg==1){
			verdict.verdict=VERDICT_FAILED;	
		}
		
		«ELSEIF param1.reason.XPeaks!==null»
		i=0;
		times=«param1.reason.XPeaks.NPeaks.DVal»;
		time=0;
		fail=0;;
		while(i<conf.used && fail==0){
			if(conf.array[i]<«param1.reason.XPeaks.cant.DVal»){
				if(time==0){
					time=i;
				}
				times--;
				if(times==0 && timeStampOracle.array[i] - timeStampOracle.array[time]< «param1.reason.XPeaks.time.DVal»){
					fail=1;	
				}
				else if(times==0){
					times=0;
				}
			}
			i++;
		}
		if(fail==1){
			verdict.verdict=VERDICT_FAILED;				
		}
		
		«ENDIF»
		«ENDFOR»
		return verdict;
	} 
	void initArray(Array *a, size_t initialSize) {
	    if(a->size==a->used){
	        a->array = malloc(initialSize * sizeof(double));
	        a->used = 0;
	        a->size = initialSize;
	    }
	}
	
	void insertArray(Array *a, double element) {
		a->array[a->used++] = element;
		if (a->used == a->size) {
	    	a->size *= 2;
	    	a->array = realloc(a->array, a->size * sizeof(double));
		}
		
	}
	
	void freeArray(Array *a) {
		free(a->array);
		a->array = NULL;
		a->used = a->size = 0;
	}
	'''
	/*«IF param.check.reference.upper!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.lower!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.same!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.notsame!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.range!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ELSEIF param.check.reference.gap!==null»
	struct Ret «param.name.toString()» («FOR name:nameList»double «name»[], «ENDFOR» double timeStamp[]){
	«ENDIF»
		struct Ret ret;
		return ret;
	}
	'''
	* 
	*/
	
	/*
	 «IF param.when!==null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when===null && param.^while!==null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»«FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){				
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» (double «param.check.name.toString()»[], «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){				
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par2: param.^while.em.elements»«IF par2.name!==null && !par2.name.equals("timeStamp")»double «par2.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSEIF param.when!==null && param.^while===null»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR» «FOR par1:param.when.em.elements»«IF par1.name!==null && !par1.name.equals("timeStamp")»double «par1.name»[],«ENDIF»«ENDFOR» double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ELSE»
		«IF param.check.name!==null»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («IF !param.check.name.equals("timeStamp")»double «param.check.name.toString()»[], «ENDIF»double timeStamp[]){
			«ENDIF»
		«ELSE»
			«IF param.check.reference.upper!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.lower!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.same!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.notsame!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){			
			«ELSEIF param.check.reference.range!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ELSEIF param.check.reference.gap!==null»
			struct Ret «param.name.toString()» («FOR par3: param.check.em.elements»«IF par3.name!==null && !par3.name.equals("timeStamp")»double «par3.name»[],«ENDIF»«ENDFOR»double timeStamp[]){
			«ENDIF»
		«ENDIF»
	«ENDIF» 
	 
	 
	 def create_oracle_c(Oracle param)'''
	#include "«param.name.toString()».h"
	«FOR param1: param.check»
		//Comment: «param1.description.value.toString»'''
		«IF param1.reference.upper!==null»
		struct Ret BelowReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.upper.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.value.DVal»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.upper.bound_upp.name.toString»){
				ret.assertret=1;
			}
			ret.diff=«param1.reference.upper.bound_upp.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ELSEIF param1.reference.lower!==null»
		struct Ret AboveReference (double «param1.name.toString()»){
			struct Ret ret;
			ret.assert=0;
			«IF param1.reference.lower.bound_lower.value!==null»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.value.DVal»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.lower.bound_lower.name.toString»){
				ret.assert=1;
			}
			ret.diff=«param1.name.toString()»-«param1.reference.lower.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.range!==null»
		struct Ret RangeReference (double «param1.name.toString»){
			struct Ret ret;
			
			«IF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSEIF param1.reference.range.bound_lower.value===null && param1.reference.range.bound_upp.value!==null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.value.DVal»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ELSEIF param1.reference.range.bound_lower.value!==null && param1.reference.range.bound_upp.value===null»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.value.DVal» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.value.DVal»;
			«ELSE»
			if(«param1.name.toString()»>=«param1.reference.range.bound_lower.name.toString» && «param1.name.toString()»<=«param1.reference.range.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.reference.range.bound_upp.name.toString»-«param1.name.toString()»;
			ret.diff_down=«param1.name.toString()»-«param1.reference.range.bound_lower.name.toString»;
			«ENDIF»
		«ELSEIF param1.reference.gap!==null»
		struct Ret GapReference (double «param1.name.toString()»){
			struct Ret ret;
			«IF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value===null && param1.reference.gap.bound_upp.value!==null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.value.DVal»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.value.DVal»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ELSEIF param1.reference.gap.bound_lower.value!==null && param1.reference.gap.bound_upp.value===null»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.value.DVal» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.value.DVal»-«param1.name.toString()»;
			«ELSE»
			if(«param1.name.toString()»<=«param1.reference.gap.bound_lower.name.toString» || «param1.name.toString()»>=«param1.reference.gap.bound_upp.name.toString»){
				ret.assert=1;
			}
			ret.diff_up=«param1.name.toString()»-«param1.reference.gap.bound_upp.name.toString»;
			ret.diff_down=«param1.reference.gap.bound_lower.name.toString»-«param1.name.toString()»;
			«ENDIF»
		«ENDIF»
			return ret;
		}
	«ENDFOR»
		

	'''*/
	

	
	/*def create_up_m(Check_Static_upper_only param)'''
	
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	def create_up_h(Check_Static_upper_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_up_c(Check_Static_upper_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <=«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input <«param.bound_up.value.DVal»){
				ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''
	
	def create_low_m(Check_Static_lower_only param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_low_h(Check_Static_lower_only param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_low_c(Check_Static_lower_only param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal»){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal»){
				ret=1;
			}
		«ENDIF»
		return ret;
	}
	'''
	
	def create_range_m(Check_Range param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_range_h(Check_Range param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_range_c(Check_Range param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input >= «param.bound_low.value.DVal» && Input <= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input > «param.bound_low.value.DVal» && Input < «param.bound_up.value.DVal» ){
						ret=1;
			}	
		«ENDIF»
		return ret;		
			
	}
	'''
	
	def create_gap_m(Check_Gap param)'''
	def= legacy_code('initialize');
	def.OutputFcnSpec= 'double y1=«param.name.toString()»(double u1)';
	def.SourceFiles= {'«param.name.toString()».c'};
	def.HeaderFiles= {'«param.name.toString()».h'};
	def.SFunctionName= 'S_«param.name.toString()»';
	legacy_code('sfcn_cmex_generate' ,def)
	legacy_code('compile' ,def)
	exit
	'''
	
	def create_gap_h(Check_Gap param)'''
	#ifndef «param.name.toString().toUpperCase»_H
	#define «param.name.toString().toUpperCase»_H
	double «param.name.toString()»(double Input);
	#endif
	'''
	
	def create_gap_c(Check_Gap param)'''
	#include "«param.name.toString()».h"
	double «param.name.toString()»(double Input){
		double ret=0;
		«IF param.inclusive_bound.value.bool»
			if(Input <= «param.bound_low.value.DVal» || Input >= «param.bound_up.value.DVal» ){
				ret=1;
			}	
		«ELSE»
			if(Input < «param.bound_low.value.DVal» || Input > «param.bound_up.value.DVal» ){
							ret=1;
			}	
		«ENDIF»
		return ret;
	}
	'''*/
}

/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class AdeptnessGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class AdeptnessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Adeptness");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsAbstractElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		//Adeptness:
		//	elements+=AbstractElement*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=AbstractElement*
		public Assignment getElementsAssignment() { return cElementsAssignment; }
		
		//AbstractElement
		public RuleCall getElementsAbstractElementParserRuleCall_0() { return cElementsAbstractElementParserRuleCall_0; }
	}
	public class AbstractElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.AbstractElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPackageDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cImportParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//AbstractElement:
		//	PackageDeclaration | Type | Import;
		@Override public ParserRule getRule() { return rule; }
		
		//PackageDeclaration | Type | Import
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PackageDeclaration
		public RuleCall getPackageDeclarationParserRuleCall_0() { return cPackageDeclarationParserRuleCall_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }
		
		//Import
		public RuleCall getImportParserRuleCall_2() { return cImportParserRuleCall_2; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//Import:
		//	'import' importedNamespace=QualifiedNameWithWildcard;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' importedNamespace=QualifiedNameWithWildcard
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }
		
		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
	}
	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName '.*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedName '.*'?
		public Group getGroup() { return cGroup; }
		
		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }
		
		//'.*'?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDataTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSignalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMonitoringFileParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Type:
		//	DataType | Signal | MonitoringFile;
		@Override public ParserRule getRule() { return rule; }
		
		//DataType | Signal | MonitoringFile
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DataType
		public RuleCall getDataTypeParserRuleCall_0() { return cDataTypeParserRuleCall_0; }
		
		//Signal
		public RuleCall getSignalParserRuleCall_1() { return cSignalParserRuleCall_1; }
		
		//MonitoringFile
		public RuleCall getMonitoringFileParserRuleCall_2() { return cMonitoringFileParserRuleCall_2; }
	}
	public class MonitoringFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.MonitoringFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMONITORINGPLANKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMonitoringPlanAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMonitoringPlanMonitoringPlanParserRuleCall_3_0 = (RuleCall)cMonitoringPlanAssignment_3.eContents().get(0);
		private final Keyword cENDMONITORINGPLANKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MonitoringFile:
		//	'MONITORINGPLAN' name=ID ':'
		//	monitoringPlan+=MonitoringPlan+ 'ENDMONITORINGPLAN'
		///*(check_static_upper+=Check_Static_upper_only)*
		// * (check_static_lower+=Check_Static_lower_only)*
		// * (check_range+=Check_Range)*
		// (check_gap+=Check_Gap)*/
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'MONITORINGPLAN' name=ID ':'
		//monitoringPlan+=MonitoringPlan+ 'ENDMONITORINGPLAN'
		public Group getGroup() { return cGroup; }
		
		//'MONITORINGPLAN'
		public Keyword getMONITORINGPLANKeyword_0() { return cMONITORINGPLANKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//monitoringPlan+=MonitoringPlan+
		public Assignment getMonitoringPlanAssignment_3() { return cMonitoringPlanAssignment_3; }
		
		//MonitoringPlan
		public RuleCall getMonitoringPlanMonitoringPlanParserRuleCall_3_0() { return cMonitoringPlanMonitoringPlanParserRuleCall_3_0; }
		
		//'ENDMONITORINGPLAN'
		public Keyword getENDMONITORINGPLANKeyword_4() { return cENDMONITORINGPLANKeyword_4; }
	}
	public class MonitoringPlanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.MonitoringPlan");
		private final Assignment cMonitoringVariablesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cMonitoringVariablesMonitoringVariableParserRuleCall_0 = (RuleCall)cMonitoringVariablesAssignment.eContents().get(0);
		
		//MonitoringPlan:
		//	monitoringVariables=MonitoringVariable;
		@Override public ParserRule getRule() { return rule; }
		
		//monitoringVariables=MonitoringVariable
		public Assignment getMonitoringVariablesAssignment() { return cMonitoringVariablesAssignment; }
		
		//MonitoringVariable
		public RuleCall getMonitoringVariablesMonitoringVariableParserRuleCall_0() { return cMonitoringVariablesMonitoringVariableParserRuleCall_0; }
	}
	public class MonitoringVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.MonitoringVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMONITORINGVARIABLEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cTypeKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMonitoringVariableDatatypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cMonitoringVariableDatatypeSig_typeParserRuleCall_5_0 = (RuleCall)cMonitoringVariableDatatypeAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cMaxKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cMaxAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cMaxDOUBLEParserRuleCall_6_1_0 = (RuleCall)cMaxAssignment_6_1.eContents().get(0);
		private final Keyword cMinKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Assignment cMinAssignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cMinDOUBLEParserRuleCall_6_3_0 = (RuleCall)cMinAssignment_6_3.eContents().get(0);
		private final Keyword cMONITORINGVARIABLEKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		///*MonitoringVariable: 
		// *  //'MonitoringVariable' '{'
		// * 	(monitoringVariable+=MonVar)*	
		// //'}';	*/
		//MonitoringVariable:
		//	'MONITORINGVARIABLE' name=ID ':'
		//	'type' ':' MonitoringVariableDatatype=Sig_type ('max:' max=DOUBLE
		//	'min:' min=DOUBLE)?
		//	// (monvar+=MonVar)+
		//	'MONITORINGVARIABLE';
		@Override public ParserRule getRule() { return rule; }
		
		//'MONITORINGVARIABLE' name=ID ':'
		//'type' ':' MonitoringVariableDatatype=Sig_type ('max:' max=DOUBLE
		//'min:' min=DOUBLE)?
		//// (monvar+=MonVar)+
		//'MONITORINGVARIABLE'
		public Group getGroup() { return cGroup; }
		
		//'MONITORINGVARIABLE'
		public Keyword getMONITORINGVARIABLEKeyword_0() { return cMONITORINGVARIABLEKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//'type'
		public Keyword getTypeKeyword_3() { return cTypeKeyword_3; }
		
		//':'
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }
		
		//MonitoringVariableDatatype=Sig_type
		public Assignment getMonitoringVariableDatatypeAssignment_5() { return cMonitoringVariableDatatypeAssignment_5; }
		
		//Sig_type
		public RuleCall getMonitoringVariableDatatypeSig_typeParserRuleCall_5_0() { return cMonitoringVariableDatatypeSig_typeParserRuleCall_5_0; }
		
		//('max:' max=DOUBLE
		//'min:' min=DOUBLE)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'max:'
		public Keyword getMaxKeyword_6_0() { return cMaxKeyword_6_0; }
		
		//max=DOUBLE
		public Assignment getMaxAssignment_6_1() { return cMaxAssignment_6_1; }
		
		//DOUBLE
		public RuleCall getMaxDOUBLEParserRuleCall_6_1_0() { return cMaxDOUBLEParserRuleCall_6_1_0; }
		
		//'min:'
		public Keyword getMinKeyword_6_2() { return cMinKeyword_6_2; }
		
		//min=DOUBLE
		public Assignment getMinAssignment_6_3() { return cMinAssignment_6_3; }
		
		//DOUBLE
		public RuleCall getMinDOUBLEParserRuleCall_6_3_0() { return cMinDOUBLEParserRuleCall_6_3_0; }
		
		//// (monvar+=MonVar)+
		//'MONITORINGVARIABLE'
		public Keyword getMONITORINGVARIABLEKeyword_7() { return cMONITORINGVARIABLEKeyword_7; }
	}
	public class Sig_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Sig_type");
		private final Assignment cSig_typeAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cSig_typeAlternatives_0 = (Alternatives)cSig_typeAssignment.eContents().get(0);
		private final Keyword cSig_typeBooleanKeyword_0_0 = (Keyword)cSig_typeAlternatives_0.eContents().get(0);
		private final Keyword cSig_typeDoubleKeyword_0_1 = (Keyword)cSig_typeAlternatives_0.eContents().get(1);
		private final Keyword cSig_typeIntKeyword_0_2 = (Keyword)cSig_typeAlternatives_0.eContents().get(2);
		
		///*MonVar:
		// * 	//'sig:' name = ID'{'
		// * 		'type:' MonitoringVariableDatatype = Sig_type
		// * 		//'signalPattern:' sigPattern = SigPattern
		// * 		//('unit:' unit = STRING)?
		// * 		('max:' max = DOUBLE
		// * 		'min:' min = DOUBLE)?
		// * 		//('timePeriod:' timePeriod_down = DOUBLE 'to' timePeriod_up = DOUBLE)?
		// * 	//'}'
		// ;*/
		//Sig_type:
		//	sig_type=('boolean' | 'double' | 'int');
		@Override public ParserRule getRule() { return rule; }
		
		//sig_type=('boolean' | 'double' | 'int')
		public Assignment getSig_typeAssignment() { return cSig_typeAssignment; }
		
		//('boolean' | 'double' | 'int')
		public Alternatives getSig_typeAlternatives_0() { return cSig_typeAlternatives_0; }
		
		//'boolean'
		public Keyword getSig_typeBooleanKeyword_0_0() { return cSig_typeBooleanKeyword_0_0; }
		
		//'double'
		public Keyword getSig_typeDoubleKeyword_0_1() { return cSig_typeDoubleKeyword_0_1; }
		
		//'int'
		public Keyword getSig_typeIntKeyword_0_2() { return cSig_typeIntKeyword_0_2; }
	}
	public class SignalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Signal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCPSKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOracleAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOracleOracleParserRuleCall_3_0 = (RuleCall)cOracleAssignment_3.eContents().get(0);
		private final Keyword cENDCPSKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////Each signal could have more than one oracles
		//Signal:
		//	'CPS' name=ID ':'
		//	oracle+=Oracle+ 'ENDCPS'
		///*(check_static_upper+=Check_Static_upper_only)*
		// * (check_static_lower+=Check_Static_lower_only)*
		// * (check_range+=Check_Range)*
		// (check_gap+=Check_Gap)*/
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'CPS' name=ID ':'
		//oracle+=Oracle+ 'ENDCPS'
		public Group getGroup() { return cGroup; }
		
		//'CPS'
		public Keyword getCPSKeyword_0() { return cCPSKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//oracle+=Oracle+
		public Assignment getOracleAssignment_3() { return cOracleAssignment_3; }
		
		//Oracle
		public RuleCall getOracleOracleParserRuleCall_3_0() { return cOracleOracleParserRuleCall_3_0; }
		
		//'ENDCPS'
		public Keyword getENDCPSKeyword_4() { return cENDCPSKeyword_4; }
	}
	public class OracleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Oracle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cORACLEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCheckAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCheckChecksParserRuleCall_3_0 = (RuleCall)cCheckAssignment_3.eContents().get(0);
		private final Keyword cENDORACLEKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Oracle:
		//	'ORACLE' name=ID ':'
		//	check+=Checks+ 'ENDORACLE';
		@Override public ParserRule getRule() { return rule; }
		
		//'ORACLE' name=ID ':'
		//check+=Checks+ 'ENDORACLE'
		public Group getGroup() { return cGroup; }
		
		//'ORACLE'
		public Keyword getORACLEKeyword_0() { return cORACLEKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//check+=Checks+
		public Assignment getCheckAssignment_3() { return cCheckAssignment_3; }
		
		//Checks
		public RuleCall getCheckChecksParserRuleCall_3_0() { return cCheckChecksParserRuleCall_3_0; }
		
		//'ENDORACLE'
		public Keyword getENDORACLEKeyword_4() { return cENDORACLEKeyword_4; }
	}
	public class ChecksElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Checks");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cChecksKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cReferenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReferenceReferenceParserRuleCall_2_0 = (RuleCall)cReferenceAssignment_2.eContents().get(0);
		private final Assignment cFailReasonAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFailReasonFailReasonParserRuleCall_3_0 = (RuleCall)cFailReasonAssignment_3.eContents().get(0);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionDescriptionParserRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		
		//Checks:
		//	'checks:' name=STRING // 'is'
		//	reference=Reference failReason+=FailReason+
		//	description=Description;
		@Override public ParserRule getRule() { return rule; }
		
		//'checks:' name=STRING // 'is'
		//reference=Reference failReason+=FailReason+
		//description=Description
		public Group getGroup() { return cGroup; }
		
		//'checks:'
		public Keyword getChecksKeyword_0() { return cChecksKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//// 'is'
		//reference=Reference
		public Assignment getReferenceAssignment_2() { return cReferenceAssignment_2; }
		
		//Reference
		public RuleCall getReferenceReferenceParserRuleCall_2_0() { return cReferenceReferenceParserRuleCall_2_0; }
		
		//failReason+=FailReason+
		public Assignment getFailReasonAssignment_3() { return cFailReasonAssignment_3; }
		
		//FailReason
		public RuleCall getFailReasonFailReasonParserRuleCall_3_0() { return cFailReasonFailReasonParserRuleCall_3_0; }
		
		//description=Description
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//Description
		public RuleCall getDescriptionDescriptionParserRuleCall_4_0() { return cDescriptionDescriptionParserRuleCall_4_0; }
	}
	public class DescriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Description");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDescriptionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Description:
		//	'Description: ' value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'Description: ' value=STRING
		public Group getGroup() { return cGroup; }
		
		//'Description: '
		public Keyword getDescriptionKeyword_0() { return cDescriptionKeyword_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}
	public class FailReasonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.FailReason");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFailsIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReasonAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReasonReasonParserRuleCall_1_0 = (RuleCall)cReasonAssignment_1.eContents().get(0);
		
		//FailReason:
		//	'fails if :'
		//	reason=Reason;
		@Override public ParserRule getRule() { return rule; }
		
		//'fails if :'
		//reason=Reason
		public Group getGroup() { return cGroup; }
		
		//'fails if :'
		public Keyword getFailsIfKeyword_0() { return cFailsIfKeyword_0; }
		
		//reason=Reason
		public Assignment getReasonAssignment_1() { return cReasonAssignment_1; }
		
		//Reason
		public RuleCall getReasonReasonParserRuleCall_1_0() { return cReasonReasonParserRuleCall_1_0; }
	}
	public class ReasonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Reason");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cHighPeakAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cHighPeakHighPeakParserRuleCall_0_0_0 = (RuleCall)cHighPeakAssignment_0_0.eContents().get(0);
		private final Assignment cHighTimeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cHighTimeHighTimeParserRuleCall_0_1_0 = (RuleCall)cHighTimeAssignment_0_1.eContents().get(0);
		private final Assignment cConstDegAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cConstDegConstDegParserRuleCall_0_2_0 = (RuleCall)cConstDegAssignment_0_2.eContents().get(0);
		private final Assignment cXPeaksAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cXPeaksXPeaksParserRuleCall_0_3_0 = (RuleCall)cXPeaksAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Reason:
		//	(highPeak=HighPeak | highTime=HighTime | constDeg=ConstDeg | xPeaks=XPeaks) ';';
		@Override public ParserRule getRule() { return rule; }
		
		//(highPeak=HighPeak | highTime=HighTime | constDeg=ConstDeg | xPeaks=XPeaks) ';'
		public Group getGroup() { return cGroup; }
		
		//(highPeak=HighPeak | highTime=HighTime | constDeg=ConstDeg | xPeaks=XPeaks)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//highPeak=HighPeak
		public Assignment getHighPeakAssignment_0_0() { return cHighPeakAssignment_0_0; }
		
		//HighPeak
		public RuleCall getHighPeakHighPeakParserRuleCall_0_0_0() { return cHighPeakHighPeakParserRuleCall_0_0_0; }
		
		//highTime=HighTime
		public Assignment getHighTimeAssignment_0_1() { return cHighTimeAssignment_0_1; }
		
		//HighTime
		public RuleCall getHighTimeHighTimeParserRuleCall_0_1_0() { return cHighTimeHighTimeParserRuleCall_0_1_0; }
		
		//constDeg=ConstDeg
		public Assignment getConstDegAssignment_0_2() { return cConstDegAssignment_0_2; }
		
		//ConstDeg
		public RuleCall getConstDegConstDegParserRuleCall_0_2_0() { return cConstDegConstDegParserRuleCall_0_2_0; }
		
		//xPeaks=XPeaks
		public Assignment getXPeaksAssignment_0_3() { return cXPeaksAssignment_0_3; }
		
		//XPeaks
		public RuleCall getXPeaksXPeaksParserRuleCall_0_3_0() { return cXPeaksXPeaksParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class XPeaksElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.XPeaks");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConfidenceIsBelowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCantDOUBLEParserRuleCall_1_0 = (RuleCall)cCantAssignment_1.eContents().get(0);
		private final Keyword cMoreThanKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNPeaksAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNPeaksDOUBLEParserRuleCall_3_0 = (RuleCall)cNPeaksAssignment_3.eContents().get(0);
		private final Keyword cTimesWithinKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTimeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTimeINTTerminalRuleCall_5_0 = (RuleCall)cTimeAssignment_5.eContents().get(0);
		private final Assignment cUnitAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cUnitTimeTypeParserRuleCall_6_0 = (RuleCall)cUnitAssignment_6.eContents().get(0);
		
		//XPeaks:
		//	'confidence is below' cant=DOUBLE 'more than' nPeaks=DOUBLE 'times within' time=INT unit=TimeType;
		@Override public ParserRule getRule() { return rule; }
		
		//'confidence is below' cant=DOUBLE 'more than' nPeaks=DOUBLE 'times within' time=INT unit=TimeType
		public Group getGroup() { return cGroup; }
		
		//'confidence is below'
		public Keyword getConfidenceIsBelowKeyword_0() { return cConfidenceIsBelowKeyword_0; }
		
		//cant=DOUBLE
		public Assignment getCantAssignment_1() { return cCantAssignment_1; }
		
		//DOUBLE
		public RuleCall getCantDOUBLEParserRuleCall_1_0() { return cCantDOUBLEParserRuleCall_1_0; }
		
		//'more than'
		public Keyword getMoreThanKeyword_2() { return cMoreThanKeyword_2; }
		
		//nPeaks=DOUBLE
		public Assignment getNPeaksAssignment_3() { return cNPeaksAssignment_3; }
		
		//DOUBLE
		public RuleCall getNPeaksDOUBLEParserRuleCall_3_0() { return cNPeaksDOUBLEParserRuleCall_3_0; }
		
		//'times within'
		public Keyword getTimesWithinKeyword_4() { return cTimesWithinKeyword_4; }
		
		//time=INT
		public Assignment getTimeAssignment_5() { return cTimeAssignment_5; }
		
		//INT
		public RuleCall getTimeINTTerminalRuleCall_5_0() { return cTimeINTTerminalRuleCall_5_0; }
		
		//unit=TimeType
		public Assignment getUnitAssignment_6() { return cUnitAssignment_6; }
		
		//TimeType
		public RuleCall getUnitTimeTypeParserRuleCall_6_0() { return cUnitTimeTypeParserRuleCall_6_0; }
	}
	public class ConstDegElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.ConstDeg");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConfidenceIsInConstantDegradationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCantDOUBLEParserRuleCall_1_0 = (RuleCall)cCantAssignment_1.eContents().get(0);
		
		//ConstDeg:
		//	'confidence is in constant degradation'  cant=DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//'confidence is in constant degradation'  cant=DOUBLE
		public Group getGroup() { return cGroup; }
		
		//'confidence is in constant degradation'
		public Keyword getConfidenceIsInConstantDegradationKeyword_0() { return cConfidenceIsInConstantDegradationKeyword_0; }
		
		//cant=DOUBLE
		public Assignment getCantAssignment_1() { return cCantAssignment_1; }
		
		//DOUBLE
		public RuleCall getCantDOUBLEParserRuleCall_1_0() { return cCantDOUBLEParserRuleCall_1_0; }
	}
	public class HighTimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.HighTime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConfidenceIsBelowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCantDOUBLEParserRuleCall_1_0 = (RuleCall)cCantAssignment_1.eContents().get(0);
		private final Keyword cWithinKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTimeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTimeDOUBLEParserRuleCall_3_0 = (RuleCall)cTimeAssignment_3.eContents().get(0);
		private final Assignment cUnitAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cUnitTimeTypeParserRuleCall_4_0 = (RuleCall)cUnitAssignment_4.eContents().get(0);
		
		//HighTime:
		//	'confidence is below' cant=DOUBLE 'within' time=DOUBLE unit=TimeType;
		@Override public ParserRule getRule() { return rule; }
		
		//'confidence is below' cant=DOUBLE 'within' time=DOUBLE unit=TimeType
		public Group getGroup() { return cGroup; }
		
		//'confidence is below'
		public Keyword getConfidenceIsBelowKeyword_0() { return cConfidenceIsBelowKeyword_0; }
		
		//cant=DOUBLE
		public Assignment getCantAssignment_1() { return cCantAssignment_1; }
		
		//DOUBLE
		public RuleCall getCantDOUBLEParserRuleCall_1_0() { return cCantDOUBLEParserRuleCall_1_0; }
		
		//'within'
		public Keyword getWithinKeyword_2() { return cWithinKeyword_2; }
		
		//time=DOUBLE
		public Assignment getTimeAssignment_3() { return cTimeAssignment_3; }
		
		//DOUBLE
		public RuleCall getTimeDOUBLEParserRuleCall_3_0() { return cTimeDOUBLEParserRuleCall_3_0; }
		
		//unit=TimeType
		public Assignment getUnitAssignment_4() { return cUnitAssignment_4; }
		
		//TimeType
		public RuleCall getUnitTimeTypeParserRuleCall_4_0() { return cUnitTimeTypeParserRuleCall_4_0; }
	}
	public class HighPeakElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.HighPeak");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConfidenceIsBelowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCantDOUBLEParserRuleCall_1_0 = (RuleCall)cCantAssignment_1.eContents().get(0);
		
		//HighPeak:
		//	'confidence is below' cant=DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//'confidence is below' cant=DOUBLE
		public Group getGroup() { return cGroup; }
		
		//'confidence is below'
		public Keyword getConfidenceIsBelowKeyword_0() { return cConfidenceIsBelowKeyword_0; }
		
		//cant=DOUBLE
		public Assignment getCantAssignment_1() { return cCantAssignment_1; }
		
		//DOUBLE
		public RuleCall getCantDOUBLEParserRuleCall_1_0() { return cCantDOUBLEParserRuleCall_1_0; }
	}
	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Reference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cUpperAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cUpperUpperParserRuleCall_0_0_0 = (RuleCall)cUpperAssignment_0_0.eContents().get(0);
		private final Assignment cLowerAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cLowerLowerParserRuleCall_0_1_0 = (RuleCall)cLowerAssignment_0_1.eContents().get(0);
		private final Assignment cRangeAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final RuleCall cRangeRangeParserRuleCall_0_2_0 = (RuleCall)cRangeAssignment_0_2.eContents().get(0);
		private final Assignment cGapAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cGapGapParserRuleCall_0_3_0 = (RuleCall)cGapAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Reference:
		//	(upper=Upper | lower=Lower | range=Range | gap=Gap) ';';
		@Override public ParserRule getRule() { return rule; }
		
		//(upper=Upper | lower=Lower | range=Range | gap=Gap) ';'
		public Group getGroup() { return cGroup; }
		
		//(upper=Upper | lower=Lower | range=Range | gap=Gap)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//upper=Upper
		public Assignment getUpperAssignment_0_0() { return cUpperAssignment_0_0; }
		
		//Upper
		public RuleCall getUpperUpperParserRuleCall_0_0_0() { return cUpperUpperParserRuleCall_0_0_0; }
		
		//lower=Lower
		public Assignment getLowerAssignment_0_1() { return cLowerAssignment_0_1; }
		
		//Lower
		public RuleCall getLowerLowerParserRuleCall_0_1_0() { return cLowerLowerParserRuleCall_0_1_0; }
		
		//range=Range
		public Assignment getRangeAssignment_0_2() { return cRangeAssignment_0_2; }
		
		//Range
		public RuleCall getRangeRangeParserRuleCall_0_2_0() { return cRangeRangeParserRuleCall_0_2_0; }
		
		//gap=Gap
		public Assignment getGapAssignment_0_3() { return cGapAssignment_0_3; }
		
		//Gap
		public RuleCall getGapGapParserRuleCall_0_3_0() { return cGapGapParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1() { return cSemicolonKeyword_1; }
	}
	public class UpperElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Upper");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsBelowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBound_uppAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBound_uppBound_upParserRuleCall_1_0 = (RuleCall)cBound_uppAssignment_1.eContents().get(0);
		
		////Oracle for upper limit --> Below reference signal
		//Upper:
		//	'is below' bound_upp=Bound_up;
		@Override public ParserRule getRule() { return rule; }
		
		//'is below' bound_upp=Bound_up
		public Group getGroup() { return cGroup; }
		
		//'is below'
		public Keyword getIsBelowKeyword_0() { return cIsBelowKeyword_0; }
		
		//bound_upp=Bound_up
		public Assignment getBound_uppAssignment_1() { return cBound_uppAssignment_1; }
		
		//Bound_up
		public RuleCall getBound_uppBound_upParserRuleCall_1_0() { return cBound_uppBound_upParserRuleCall_1_0; }
	}
	public class LowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Lower");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsAboveKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBound_lowerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBound_lowerBound_DownParserRuleCall_1_0 = (RuleCall)cBound_lowerAssignment_1.eContents().get(0);
		
		////Oracle for lower limit --> Above reference signal
		//Lower:
		//	'is above' bound_lower=Bound_Down;
		@Override public ParserRule getRule() { return rule; }
		
		//'is above' bound_lower=Bound_Down
		public Group getGroup() { return cGroup; }
		
		//'is above'
		public Keyword getIsAboveKeyword_0() { return cIsAboveKeyword_0; }
		
		//bound_lower=Bound_Down
		public Assignment getBound_lowerAssignment_1() { return cBound_lowerAssignment_1; }
		
		//Bound_Down
		public RuleCall getBound_lowerBound_DownParserRuleCall_1_0() { return cBound_lowerBound_DownParserRuleCall_1_0; }
	}
	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsInRangeBetweenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBound_lowerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBound_lowerBound_DownParserRuleCall_1_0 = (RuleCall)cBound_lowerAssignment_1.eContents().get(0);
		private final Keyword cAndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBound_uppAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBound_uppBound_upParserRuleCall_3_0 = (RuleCall)cBound_uppAssignment_3.eContents().get(0);
		
		////Oracle for Above and Below limit --> In range reference signal
		//Range:
		//	'is in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up;
		@Override public ParserRule getRule() { return rule; }
		
		//'is in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up
		public Group getGroup() { return cGroup; }
		
		//'is in range between'
		public Keyword getIsInRangeBetweenKeyword_0() { return cIsInRangeBetweenKeyword_0; }
		
		//bound_lower=Bound_Down
		public Assignment getBound_lowerAssignment_1() { return cBound_lowerAssignment_1; }
		
		//Bound_Down
		public RuleCall getBound_lowerBound_DownParserRuleCall_1_0() { return cBound_lowerBound_DownParserRuleCall_1_0; }
		
		//'and'
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
		
		//bound_upp=Bound_up
		public Assignment getBound_uppAssignment_3() { return cBound_uppAssignment_3; }
		
		//Bound_up
		public RuleCall getBound_uppBound_upParserRuleCall_3_0() { return cBound_uppBound_upParserRuleCall_3_0; }
	}
	public class GapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Gap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotInRangeBetweenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBound_lowerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBound_lowerBound_DownParserRuleCall_1_0 = (RuleCall)cBound_lowerAssignment_1.eContents().get(0);
		private final Keyword cAndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBound_uppAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBound_uppBound_upParserRuleCall_3_0 = (RuleCall)cBound_uppAssignment_3.eContents().get(0);
		
		////Oracle for !Above and !Below limit --> Gap reference signal
		//Gap:
		//	'not in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up;
		@Override public ParserRule getRule() { return rule; }
		
		//'not in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up
		public Group getGroup() { return cGroup; }
		
		//'not in range between'
		public Keyword getNotInRangeBetweenKeyword_0() { return cNotInRangeBetweenKeyword_0; }
		
		//bound_lower=Bound_Down
		public Assignment getBound_lowerAssignment_1() { return cBound_lowerAssignment_1; }
		
		//Bound_Down
		public RuleCall getBound_lowerBound_DownParserRuleCall_1_0() { return cBound_lowerBound_DownParserRuleCall_1_0; }
		
		//'and'
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
		
		//bound_upp=Bound_up
		public Assignment getBound_uppAssignment_3() { return cBound_uppAssignment_3; }
		
		//Bound_up
		public RuleCall getBound_uppBound_upParserRuleCall_3_0() { return cBound_uppBound_upParserRuleCall_3_0; }
	}
	public class InclusiveBoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.InclusiveBound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInclusiveBoundKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueBOOLEANParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		////If the limits must be included ==
		//InclusiveBound:
		//	'inclusiveBound' name=ID '=' value=BOOLEAN;
		@Override public ParserRule getRule() { return rule; }
		
		//'inclusiveBound' name=ID '=' value=BOOLEAN
		public Group getGroup() { return cGroup; }
		
		//'inclusiveBound'
		public Keyword getInclusiveBoundKeyword_0() { return cInclusiveBoundKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//value=BOOLEAN
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//BOOLEAN
		public RuleCall getValueBOOLEANParserRuleCall_3_0() { return cValueBOOLEANParserRuleCall_3_0; }
	}
	public class Bound_upElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Bound_up");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDOUBLEParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		////Upper limit
		//Bound_up:
		//	value=DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DOUBLE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DOUBLE
		public RuleCall getValueDOUBLEParserRuleCall_0() { return cValueDOUBLEParserRuleCall_0; }
	}
	public class Bound_DownElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.Bound_Down");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDOUBLEParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		////Lower limit
		//Bound_Down:
		//	value=DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DOUBLE
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//DOUBLE
		public RuleCall getValueDOUBLEParserRuleCall_0() { return cValueDOUBLEParserRuleCall_0; }
	}
	public class BOOLEANElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.BOOLEAN");
		private final Assignment cBoolAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBoolBParserRuleCall_0 = (RuleCall)cBoolAssignment.eContents().get(0);
		
		////Boolean declaration
		//BOOLEAN:
		//	bool=b;
		@Override public ParserRule getRule() { return rule; }
		
		//bool=b
		public Assignment getBoolAssignment() { return cBoolAssignment; }
		
		//b
		public RuleCall getBoolBParserRuleCall_0() { return cBoolBParserRuleCall_0; }
	}
	public class BElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.b");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//b ecore::EBoolean:
		//	'true' | 'false';
		@Override public ParserRule getRule() { return rule; }
		
		//'true' | 'false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'true'
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class DOUBLEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.DOUBLE");
		private final Assignment cDValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDValDParserRuleCall_0 = (RuleCall)cDValAssignment.eContents().get(0);
		
		////Double declaration
		//DOUBLE:
		//	dVal=d;
		@Override public ParserRule getRule() { return rule; }
		
		//dVal=d
		public Assignment getDValAssignment() { return cDValAssignment; }
		
		//d
		public RuleCall getDValDParserRuleCall_0() { return cDValDParserRuleCall_0; }
	}
	public class DElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.d");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//d ecore::EDouble:
		//	'-'? INT ('.'INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT ('.'INT)?
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//('.'INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'.'
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	public class TimeTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.TimeType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTimeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Keyword cTimeMilisecondsKeyword_0_0 = (Keyword)cTimeAssignment_0.eContents().get(0);
		private final Assignment cTimeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cTimeSecondsKeyword_1_0 = (Keyword)cTimeAssignment_1.eContents().get(0);
		private final Assignment cTimeAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final Keyword cTimeMinutesKeyword_2_0 = (Keyword)cTimeAssignment_2.eContents().get(0);
		private final Assignment cTimeAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final Keyword cTimeHoursKeyword_3_0 = (Keyword)cTimeAssignment_3.eContents().get(0);
		
		//TimeType:
		//	time='miliseconds' | time='seconds' | time='minutes' | time='hours';
		@Override public ParserRule getRule() { return rule; }
		
		//time='miliseconds' | time='seconds' | time='minutes' | time='hours'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//time='miliseconds'
		public Assignment getTimeAssignment_0() { return cTimeAssignment_0; }
		
		//'miliseconds'
		public Keyword getTimeMilisecondsKeyword_0_0() { return cTimeMilisecondsKeyword_0_0; }
		
		//time='seconds'
		public Assignment getTimeAssignment_1() { return cTimeAssignment_1; }
		
		//'seconds'
		public Keyword getTimeSecondsKeyword_1_0() { return cTimeSecondsKeyword_1_0; }
		
		//time='minutes'
		public Assignment getTimeAssignment_2() { return cTimeAssignment_2; }
		
		//'minutes'
		public Keyword getTimeMinutesKeyword_2_0() { return cTimeMinutesKeyword_2_0; }
		
		//time='hours'
		public Assignment getTimeAssignment_3() { return cTimeAssignment_3; }
		
		//'hours'
		public Keyword getTimeHoursKeyword_3_0() { return cTimeHoursKeyword_3_0; }
	}
	public class DataTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.DataType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatatypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		////DataType declaration
		//DataType:
		//	'datatype' name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'datatype' name=ID
		public Group getGroup() { return cGroup; }
		
		//'datatype'
		public Keyword getDatatypeKeyword_0() { return cDatatypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class PackageDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Adeptness.PackageDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsAbstractElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////Package declaration
		//PackageDeclaration:
		//	'package' name=QualifiedName '{'
		//	elements+=AbstractElement*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=QualifiedName '{'
		//elements+=AbstractElement*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//elements+=AbstractElement*
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }
		
		//AbstractElement
		public RuleCall getElementsAbstractElementParserRuleCall_3_0() { return cElementsAbstractElementParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	
	
	private final AdeptnessElements pAdeptness;
	private final AbstractElementElements pAbstractElement;
	private final ImportElements pImport;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final QualifiedNameElements pQualifiedName;
	private final TypeElements pType;
	private final MonitoringFileElements pMonitoringFile;
	private final MonitoringPlanElements pMonitoringPlan;
	private final MonitoringVariableElements pMonitoringVariable;
	private final Sig_typeElements pSig_type;
	private final SignalElements pSignal;
	private final OracleElements pOracle;
	private final ChecksElements pChecks;
	private final DescriptionElements pDescription;
	private final FailReasonElements pFailReason;
	private final ReasonElements pReason;
	private final XPeaksElements pXPeaks;
	private final ConstDegElements pConstDeg;
	private final HighTimeElements pHighTime;
	private final HighPeakElements pHighPeak;
	private final ReferenceElements pReference;
	private final UpperElements pUpper;
	private final LowerElements pLower;
	private final RangeElements pRange;
	private final GapElements pGap;
	private final InclusiveBoundElements pInclusiveBound;
	private final Bound_upElements pBound_up;
	private final Bound_DownElements pBound_Down;
	private final BOOLEANElements pBOOLEAN;
	private final BElements pB;
	private final DOUBLEElements pDOUBLE;
	private final DElements pD;
	private final TimeTypeElements pTimeType;
	private final DataTypeElements pDataType;
	private final PackageDeclarationElements pPackageDeclaration;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public AdeptnessGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pAdeptness = new AdeptnessElements();
		this.pAbstractElement = new AbstractElementElements();
		this.pImport = new ImportElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pType = new TypeElements();
		this.pMonitoringFile = new MonitoringFileElements();
		this.pMonitoringPlan = new MonitoringPlanElements();
		this.pMonitoringVariable = new MonitoringVariableElements();
		this.pSig_type = new Sig_typeElements();
		this.pSignal = new SignalElements();
		this.pOracle = new OracleElements();
		this.pChecks = new ChecksElements();
		this.pDescription = new DescriptionElements();
		this.pFailReason = new FailReasonElements();
		this.pReason = new ReasonElements();
		this.pXPeaks = new XPeaksElements();
		this.pConstDeg = new ConstDegElements();
		this.pHighTime = new HighTimeElements();
		this.pHighPeak = new HighPeakElements();
		this.pReference = new ReferenceElements();
		this.pUpper = new UpperElements();
		this.pLower = new LowerElements();
		this.pRange = new RangeElements();
		this.pGap = new GapElements();
		this.pInclusiveBound = new InclusiveBoundElements();
		this.pBound_up = new Bound_upElements();
		this.pBound_Down = new Bound_DownElements();
		this.pBOOLEAN = new BOOLEANElements();
		this.pB = new BElements();
		this.pDOUBLE = new DOUBLEElements();
		this.pD = new DElements();
		this.pTimeType = new TimeTypeElements();
		this.pDataType = new DataTypeElements();
		this.pPackageDeclaration = new PackageDeclarationElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.Adeptness".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Adeptness:
	//	elements+=AbstractElement*;
	public AdeptnessElements getAdeptnessAccess() {
		return pAdeptness;
	}
	
	public ParserRule getAdeptnessRule() {
		return getAdeptnessAccess().getRule();
	}
	
	//AbstractElement:
	//	PackageDeclaration | Type | Import;
	public AbstractElementElements getAbstractElementAccess() {
		return pAbstractElement;
	}
	
	public ParserRule getAbstractElementRule() {
		return getAbstractElementAccess().getRule();
	}
	
	//Import:
	//	'import' importedNamespace=QualifiedNameWithWildcard;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	QualifiedName '.*'?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//QualifiedName:
	//	ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//Type:
	//	DataType | Signal | MonitoringFile;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//MonitoringFile:
	//	'MONITORINGPLAN' name=ID ':'
	//	monitoringPlan+=MonitoringPlan+ 'ENDMONITORINGPLAN'
	///*(check_static_upper+=Check_Static_upper_only)*
	// * (check_static_lower+=Check_Static_lower_only)*
	// * (check_range+=Check_Range)*
	// (check_gap+=Check_Gap)*/
	//;
	public MonitoringFileElements getMonitoringFileAccess() {
		return pMonitoringFile;
	}
	
	public ParserRule getMonitoringFileRule() {
		return getMonitoringFileAccess().getRule();
	}
	
	//MonitoringPlan:
	//	monitoringVariables=MonitoringVariable;
	public MonitoringPlanElements getMonitoringPlanAccess() {
		return pMonitoringPlan;
	}
	
	public ParserRule getMonitoringPlanRule() {
		return getMonitoringPlanAccess().getRule();
	}
	
	///*MonitoringVariable: 
	// *  //'MonitoringVariable' '{'
	// * 	(monitoringVariable+=MonVar)*	
	// //'}';	*/
	//MonitoringVariable:
	//	'MONITORINGVARIABLE' name=ID ':'
	//	'type' ':' MonitoringVariableDatatype=Sig_type ('max:' max=DOUBLE
	//	'min:' min=DOUBLE)?
	//	// (monvar+=MonVar)+
	//	'MONITORINGVARIABLE';
	public MonitoringVariableElements getMonitoringVariableAccess() {
		return pMonitoringVariable;
	}
	
	public ParserRule getMonitoringVariableRule() {
		return getMonitoringVariableAccess().getRule();
	}
	
	///*MonVar:
	// * 	//'sig:' name = ID'{'
	// * 		'type:' MonitoringVariableDatatype = Sig_type
	// * 		//'signalPattern:' sigPattern = SigPattern
	// * 		//('unit:' unit = STRING)?
	// * 		('max:' max = DOUBLE
	// * 		'min:' min = DOUBLE)?
	// * 		//('timePeriod:' timePeriod_down = DOUBLE 'to' timePeriod_up = DOUBLE)?
	// * 	//'}'
	// ;*/
	//Sig_type:
	//	sig_type=('boolean' | 'double' | 'int');
	public Sig_typeElements getSig_typeAccess() {
		return pSig_type;
	}
	
	public ParserRule getSig_typeRule() {
		return getSig_typeAccess().getRule();
	}
	
	////Each signal could have more than one oracles
	//Signal:
	//	'CPS' name=ID ':'
	//	oracle+=Oracle+ 'ENDCPS'
	///*(check_static_upper+=Check_Static_upper_only)*
	// * (check_static_lower+=Check_Static_lower_only)*
	// * (check_range+=Check_Range)*
	// (check_gap+=Check_Gap)*/
	//;
	public SignalElements getSignalAccess() {
		return pSignal;
	}
	
	public ParserRule getSignalRule() {
		return getSignalAccess().getRule();
	}
	
	//Oracle:
	//	'ORACLE' name=ID ':'
	//	check+=Checks+ 'ENDORACLE';
	public OracleElements getOracleAccess() {
		return pOracle;
	}
	
	public ParserRule getOracleRule() {
		return getOracleAccess().getRule();
	}
	
	//Checks:
	//	'checks:' name=STRING // 'is'
	//	reference=Reference failReason+=FailReason+
	//	description=Description;
	public ChecksElements getChecksAccess() {
		return pChecks;
	}
	
	public ParserRule getChecksRule() {
		return getChecksAccess().getRule();
	}
	
	//Description:
	//	'Description: ' value=STRING;
	public DescriptionElements getDescriptionAccess() {
		return pDescription;
	}
	
	public ParserRule getDescriptionRule() {
		return getDescriptionAccess().getRule();
	}
	
	//FailReason:
	//	'fails if :'
	//	reason=Reason;
	public FailReasonElements getFailReasonAccess() {
		return pFailReason;
	}
	
	public ParserRule getFailReasonRule() {
		return getFailReasonAccess().getRule();
	}
	
	//Reason:
	//	(highPeak=HighPeak | highTime=HighTime | constDeg=ConstDeg | xPeaks=XPeaks) ';';
	public ReasonElements getReasonAccess() {
		return pReason;
	}
	
	public ParserRule getReasonRule() {
		return getReasonAccess().getRule();
	}
	
	//XPeaks:
	//	'confidence is below' cant=DOUBLE 'more than' nPeaks=DOUBLE 'times within' time=INT unit=TimeType;
	public XPeaksElements getXPeaksAccess() {
		return pXPeaks;
	}
	
	public ParserRule getXPeaksRule() {
		return getXPeaksAccess().getRule();
	}
	
	//ConstDeg:
	//	'confidence is in constant degradation'  cant=DOUBLE;
	public ConstDegElements getConstDegAccess() {
		return pConstDeg;
	}
	
	public ParserRule getConstDegRule() {
		return getConstDegAccess().getRule();
	}
	
	//HighTime:
	//	'confidence is below' cant=DOUBLE 'within' time=DOUBLE unit=TimeType;
	public HighTimeElements getHighTimeAccess() {
		return pHighTime;
	}
	
	public ParserRule getHighTimeRule() {
		return getHighTimeAccess().getRule();
	}
	
	//HighPeak:
	//	'confidence is below' cant=DOUBLE;
	public HighPeakElements getHighPeakAccess() {
		return pHighPeak;
	}
	
	public ParserRule getHighPeakRule() {
		return getHighPeakAccess().getRule();
	}
	
	//Reference:
	//	(upper=Upper | lower=Lower | range=Range | gap=Gap) ';';
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}
	
	////Oracle for upper limit --> Below reference signal
	//Upper:
	//	'is below' bound_upp=Bound_up;
	public UpperElements getUpperAccess() {
		return pUpper;
	}
	
	public ParserRule getUpperRule() {
		return getUpperAccess().getRule();
	}
	
	////Oracle for lower limit --> Above reference signal
	//Lower:
	//	'is above' bound_lower=Bound_Down;
	public LowerElements getLowerAccess() {
		return pLower;
	}
	
	public ParserRule getLowerRule() {
		return getLowerAccess().getRule();
	}
	
	////Oracle for Above and Below limit --> In range reference signal
	//Range:
	//	'is in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up;
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}
	
	////Oracle for !Above and !Below limit --> Gap reference signal
	//Gap:
	//	'not in range between' bound_lower=Bound_Down 'and' bound_upp=Bound_up;
	public GapElements getGapAccess() {
		return pGap;
	}
	
	public ParserRule getGapRule() {
		return getGapAccess().getRule();
	}
	
	////If the limits must be included ==
	//InclusiveBound:
	//	'inclusiveBound' name=ID '=' value=BOOLEAN;
	public InclusiveBoundElements getInclusiveBoundAccess() {
		return pInclusiveBound;
	}
	
	public ParserRule getInclusiveBoundRule() {
		return getInclusiveBoundAccess().getRule();
	}
	
	////Upper limit
	//Bound_up:
	//	value=DOUBLE;
	public Bound_upElements getBound_upAccess() {
		return pBound_up;
	}
	
	public ParserRule getBound_upRule() {
		return getBound_upAccess().getRule();
	}
	
	////Lower limit
	//Bound_Down:
	//	value=DOUBLE;
	public Bound_DownElements getBound_DownAccess() {
		return pBound_Down;
	}
	
	public ParserRule getBound_DownRule() {
		return getBound_DownAccess().getRule();
	}
	
	////Boolean declaration
	//BOOLEAN:
	//	bool=b;
	public BOOLEANElements getBOOLEANAccess() {
		return pBOOLEAN;
	}
	
	public ParserRule getBOOLEANRule() {
		return getBOOLEANAccess().getRule();
	}
	
	//b ecore::EBoolean:
	//	'true' | 'false';
	public BElements getBAccess() {
		return pB;
	}
	
	public ParserRule getBRule() {
		return getBAccess().getRule();
	}
	
	////Double declaration
	//DOUBLE:
	//	dVal=d;
	public DOUBLEElements getDOUBLEAccess() {
		return pDOUBLE;
	}
	
	public ParserRule getDOUBLERule() {
		return getDOUBLEAccess().getRule();
	}
	
	//d ecore::EDouble:
	//	'-'? INT ('.'INT)?;
	public DElements getDAccess() {
		return pD;
	}
	
	public ParserRule getDRule() {
		return getDAccess().getRule();
	}
	
	//TimeType:
	//	time='miliseconds' | time='seconds' | time='minutes' | time='hours';
	public TimeTypeElements getTimeTypeAccess() {
		return pTimeType;
	}
	
	public ParserRule getTimeTypeRule() {
		return getTimeTypeAccess().getRule();
	}
	
	////DataType declaration
	//DataType:
	//	'datatype' name=ID;
	public DataTypeElements getDataTypeAccess() {
		return pDataType;
	}
	
	public ParserRule getDataTypeRule() {
		return getDataTypeAccess().getRule();
	}
	
	////Package declaration
	//PackageDeclaration:
	//	'package' name=QualifiedName '{'
	//	elements+=AbstractElement*
	//	'}';
	public PackageDeclarationElements getPackageDeclarationAccess() {
		return pPackageDeclaration;
	}
	
	public ParserRule getPackageDeclarationRule() {
		return getPackageDeclarationAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
